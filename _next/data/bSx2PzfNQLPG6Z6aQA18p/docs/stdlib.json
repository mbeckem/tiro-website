{"pageProps":{"slug":"stdlib","frontMatter":{"title":"The standard library","slug":"/stdlib"},"mdx":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"the-standard-library\"\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#the-standard-library\"\n  }, \"#\"), \"The standard library\"), mdx(\"p\", null, \"Basic types and functions provided by the runtime.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import std;\\n\")), mdx(\"h2\", {\n    \"id\": \"contents\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#contents\"\n  }, \"#\"), \"Contents\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#basic-types-and-functions\"\n  }, \"Basic types and functions\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-boolean\"\n  }, \"type Boolean\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-integer\"\n  }, \"type Integer\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-float\"\n  }, \"type Float\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-null\"\n  }, \"type Null\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-string\"\n  }, \"type String\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-symbol\"\n  }, \"type Symbol\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-function\"\n  }, \"type Function\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-module\"\n  }, \"type Module\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-nativeobject\"\n  }, \"type NativeObject\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-nativepointer\"\n  }, \"type NativePointer\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-type\"\n  }, \"type Type\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-type_of\"\n  }, \"func type_of\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#containers\"\n  }, \"Containers\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-tuple\"\n  }, \"type Tuple\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-record\"\n  }, \"type Record\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-array\"\n  }, \"type Array\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-buffer\"\n  }, \"type Buffer\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-map\"\n  }, \"type Map\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-set\"\n  }, \"type Set\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#strings\"\n  }, \"Strings\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-stringslice\"\n  }, \"type StringSlice\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-stringbuilder\"\n  }, \"type StringBuilder\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-new_string_builder\"\n  }, \"func new_string_builder\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#input-and-output\"\n  }, \"Input and Output\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-print\"\n  }, \"func print\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-loop_timestamp\"\n  }, \"func loop_timestamp\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#coroutines\"\n  }, \"Coroutines\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-coroutine\"\n  }, \"type Coroutine\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-coroutinetoken\"\n  }, \"type CoroutineToken\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-current_coroutine\"\n  }, \"func current_coroutine\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-launch\"\n  }, \"func launch\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-dispatch\"\n  }, \"func dispatch\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-coroutine_token\"\n  }, \"func coroutine_token\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-yield_coroutine\"\n  }, \"func yield_coroutine\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#error-handling\"\n  }, \"Error handling\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-result\"\n  }, \"type Result\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-success\"\n  }, \"func success\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-failure\"\n  }, \"func failure\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#type-exception\"\n  }, \"type Exception\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-panic\"\n  }, \"func panic\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#func-catch_panic\"\n  }, \"func catch_panic\"))))), mdx(\"h2\", {\n    \"id\": \"basic-types-and-functions\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#basic-types-and-functions\"\n  }, \"#\"), \"Basic types and functions\"), mdx(\"h3\", {\n    \"id\": \"type-boolean\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-boolean\"\n  }, \"#\"), \"type Boolean\"), mdx(\"p\", null, \"The type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-integer\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-integer\"\n  }, \"#\"), \"type Integer\"), mdx(\"p\", null, \"The type of integer expressions such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"7\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x1F\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-float\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-float\"\n  }, \"#\"), \"type Float\"), mdx(\"p\", null, \"Type type of floating point expressions such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1.25\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-null\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-null\"\n  }, \"#\"), \"type Null\"), mdx(\"p\", null, \"The type of the constant \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-string\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-string\"\n  }, \"#\"), \"type String\"), mdx(\"p\", null, \"The type of all string expressions.\\nStrings are immutable.\"), mdx(\"p\", null, \"TODO: Unicode strings\"), mdx(\"p\", null, \"TODO: Internal representation is guaranteed to be UTF-8\"), mdx(\"h3\", {\n    \"id\": \"type-symbol\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-symbol\"\n  }, \"#\"), \"type Symbol\"), mdx(\"p\", null, \"The type of symbol literals, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#answer\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-function\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-function\"\n  }, \"#\"), \"type Function\"), mdx(\"p\", null, \"The type of all functions.\"), mdx(\"h3\", {\n    \"id\": \"type-module\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-module\"\n  }, \"#\"), \"type Module\"), mdx(\"p\", null, \"The type of all modules:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import std;\\n// std.type_of(std) == std.Module\\n\")), mdx(\"h3\", {\n    \"id\": \"type-nativeobject\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-nativeobject\"\n  }, \"#\"), \"type NativeObject\"), mdx(\"p\", null, \"The type of native objects that have been exposed to tiro.\\nThe tiro runtime manages the lifetime (and the storage) of these objects, which usually includes invoking a native finalizer when the object is collected.\"), mdx(\"h3\", {\n    \"id\": \"type-nativepointer\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-nativepointer\"\n  }, \"#\"), \"type NativePointer\"), mdx(\"p\", null, \"The type of a native pointer that has been exposed to tiro.\\nThe tiro runtime does \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" manage these objects in any way, which makes them very cheap to use.\"), mdx(\"h3\", {\n    \"id\": \"type-type\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-type\"\n  }, \"#\"), \"type Type\"), mdx(\"p\", null, \"The type of all types. In other words, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std.type_of(value)\"), \" will always return an instance of this type for any kind of value.\"), mdx(\"h3\", {\n    \"id\": \"func-type_of\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-type_of\"\n  }, \"#\"), \"func type_of\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func type_of(v: Value): Type;\\n\")), mdx(\"p\", null, \"Returns the type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"v\"), \". For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"assert(std.type_of(true) == std.Boolean);\\n\")), mdx(\"h2\", {\n    \"id\": \"containers\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#containers\"\n  }, \"#\"), \"Containers\"), mdx(\"h3\", {\n    \"id\": \"type-tuple\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-tuple\"\n  }, \"#\"), \"type Tuple\"), mdx(\"p\", null, \"The type of all tuples, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"()\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(1,)\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(1, 2)\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-record\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-record\"\n  }, \"#\"), \"type Record\"), mdx(\"p\", null, \"The type of all records, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(:)\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(foo: \\\"bar\\\")\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-array\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-array\"\n  }, \"#\"), \"type Array\"), mdx(\"p\", null, \"The type of all arrays, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[]\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[a, b, c]\"), \".\"), mdx(\"p\", null, \"An array is a dynamic sequence of items that can grow or shrink as needed.\\nExisting items can be read or written using the indexing operator, e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const first = array[0]\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array[0] = \\\"first\\\"\"), \".\\nThe sequence of items can be manipulated using the methods below.\"), mdx(\"h4\", {\n    \"id\": \"func-arraysize\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-arraysize\"\n  }, \"#\"), \"func Array.size\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Array.size(): Integer;\\n\")), mdx(\"p\", null, \"Returns the number of items in the array.\"), mdx(\"h4\", {\n    \"id\": \"func-arrayappend\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-arrayappend\"\n  }, \"#\"), \"func Array.append\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Array.append(v: Value);\\n\")), mdx(\"p\", null, \"Appends \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"v\"), \" to the array.\"), mdx(\"h4\", {\n    \"id\": \"func-arrayclear\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-arrayclear\"\n  }, \"#\"), \"func Array.clear\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Array.clear()\\n\")), mdx(\"p\", null, \"Removes all items from the array.\"), mdx(\"h3\", {\n    \"id\": \"type-buffer\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-buffer\"\n  }, \"#\"), \"type Buffer\"), mdx(\"p\", null, \"Buffers reference a raw region of memory, i.e. a blog of bytes.\\nThey are especially useful when doing I/O or when manipulating large amounts of data.\"), mdx(\"p\", null, \"TODO: usage\"), mdx(\"h4\", {\n    \"id\": \"func-buffersize\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-buffersize\"\n  }, \"#\"), \"func Buffer.size\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Buffer.size(): Integer;\\n\")), mdx(\"p\", null, \"Returns the number of items in the buffer.\"), mdx(\"h3\", {\n    \"id\": \"type-map\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-map\"\n  }, \"#\"), \"type Map\"), mdx(\"p\", null, \"A map is a container that associates \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"keys\"), \" with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"values\"), \".\\nThe key-value associations can be manipulated at will.\\nGiven a key, a map allows for efficient lookup (and update) of the associated value.\"), mdx(\"p\", null, \"Maps are implemented as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Hash_table\"\n  }, \"hash tables\"), \".\"), mdx(\"h4\", {\n    \"id\": \"map-insertion-order\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#map-insertion-order\"\n  }, \"#\"), \"Insertion order\"), mdx(\"p\", null, \"Contrary to most other hash table implementations, tiro's map preserves the insertion order of its mappings.\\nWhen iterating a map, keys and values are visited in the order in which they were inserted:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A new key-value mapping (i.e. a key that was not already in the map) is always inserted at the end.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Updating an existing key-value mapping (i.e. key already exists in the map) does not change its order in the map.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Removing a key-value mapping preserves the order of all remaining mappings.\")), mdx(\"span\", {\n    className: \"caption\"\n  }, \"Example: iterating over a map\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import std;\\n\\nexport func main() {\\n    const m = map{};\\n    m[1] = \\\"one\\\";\\n    m[2] = \\\"two\\\";\\n    m[3] = \\\"three\\\";\\n\\n    // Guaranteed output:\\n    // 1 one\\n    // 2 two\\n    // 3 three\\n    for (key, value) in m {\\n        std.print(key, value);\\n    }\\n}\\n\")), mdx(\"h4\", {\n    \"id\": \"func-mapsize\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-mapsize\"\n  }, \"#\"), \"func Map.size\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Map.size(): Integer;\\n\")), mdx(\"p\", null, \"Returns the number of key-value mappings in the map.\"), mdx(\"h4\", {\n    \"id\": \"func-mapcontains\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-mapcontains\"\n  }, \"#\"), \"func Map.contains\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Map.contains(key: Value): Boolean;\\n\")), mdx(\"p\", null, \"Returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" if there is a value associated with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" otherwise.\"), mdx(\"h4\", {\n    \"id\": \"func-mapkeys\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-mapkeys\"\n  }, \"#\"), \"func Map.keys\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Map.keys(): Iterable;\\n\")), mdx(\"p\", null, \"Returns an iterable view over the keys within the map.\\nThe iteration order is the same as the map's order.\"), mdx(\"h4\", {\n    \"id\": \"func-mapvalues\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-mapvalues\"\n  }, \"#\"), \"func Map.values\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Map.values(): Iterable;\\n\")), mdx(\"p\", null, \"Returns an iterable view over the values within the map.\\nThe iteration order is the same as the map's order.\"), mdx(\"h4\", {\n    \"id\": \"func-mapclear\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-mapclear\"\n  }, \"#\"), \"func Map.clear\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Map.clear();\\n\")), mdx(\"p\", null, \"Removes all key-value mappings from the map.\"), mdx(\"h4\", {\n    \"id\": \"func-mapremove\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-mapremove\"\n  }, \"#\"), \"func Map.remove\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Map.remove(key: Value);\\n\")), mdx(\"p\", null, \"Removes the key-value mapping for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key\"), \".\\nDoes nothing if there is no such mapping.\"), mdx(\"p\", null, \"TODO: Return true/false?\"), mdx(\"h3\", {\n    \"id\": \"type-set\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-set\"\n  }, \"#\"), \"type Set\"), mdx(\"p\", null, \"A set is a container that stores unique items.\\nItems can be inserted or removed at will, and their existence can be tested efficiently.\"), mdx(\"p\", null, \"Like maps, they are implemented as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Hash_table\"\n  }, \"hash tables\"), \".\"), mdx(\"h4\", {\n    \"id\": \"set-insertion-order\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#set-insertion-order\"\n  }, \"#\"), \"Insertion order\"), mdx(\"p\", null, \"When iterating a set, its items are visited in the order they were inserted in.\\nSee also \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#map-insertion-order\"\n  }, \"map insertion order\"), \".\"), mdx(\"h4\", {\n    \"id\": \"func-setsize\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-setsize\"\n  }, \"#\"), \"func Set.size\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Set.size(): Integer;\\n\")), mdx(\"p\", null, \"Returns the number of items in the set.\"), mdx(\"h4\", {\n    \"id\": \"func-setcontains\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-setcontains\"\n  }, \"#\"), \"func Set.contains\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Set.contains(item: Value): Boolean;\\n\")), mdx(\"p\", null, \"Returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" if the set contains \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"item\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" otherwise.\"), mdx(\"h4\", {\n    \"id\": \"func-setclear\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-setclear\"\n  }, \"#\"), \"func Set.clear\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Set.clear();\\n\")), mdx(\"p\", null, \"Removes all items from the set.\"), mdx(\"h4\", {\n    \"id\": \"func-setinsert\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-setinsert\"\n  }, \"#\"), \"func Set.insert\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Set.insert(item: Value): Boolean;\\n\")), mdx(\"p\", null, \"Inserts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"item\"), \" into the set.\\nReturns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" if item has been inserted, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" if it already existed.\"), mdx(\"h4\", {\n    \"id\": \"func-setremove\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-setremove\"\n  }, \"#\"), \"func Set.remove\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Set.remove(item: Value);\\n\")), mdx(\"p\", null, \"Removes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"item\"), \" from the set.\\nDoes nothing if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"item\"), \" does not exist in the set.\"), mdx(\"p\", null, \"TODO: Return true/false?\"), mdx(\"h2\", {\n    \"id\": \"strings\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#strings\"\n  }, \"#\"), \"Strings\"), mdx(\"h3\", {\n    \"id\": \"type-stringslice\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-stringslice\"\n  }, \"#\"), \"type StringSlice\"), mdx(\"h3\", {\n    \"id\": \"type-stringbuilder\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-stringbuilder\"\n  }, \"#\"), \"type StringBuilder\"), mdx(\"h3\", {\n    \"id\": \"func-new_string_builder\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-new_string_builder\"\n  }, \"#\"), \"func new_string_builder\"), mdx(\"h2\", {\n    \"id\": \"input-and-output\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#input-and-output\"\n  }, \"#\"), \"Input and Output\"), mdx(\"h3\", {\n    \"id\": \"func-print\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-print\"\n  }, \"#\"), \"func print\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func print(values...: Value...);\\n\")), mdx(\"p\", null, \"Prints the given values followed by a new line.\"), mdx(\"h3\", {\n    \"id\": \"func-loop_timestamp\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-loop_timestamp\"\n  }, \"#\"), \"func loop_timestamp\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func loop_timestamp(): Integer;\\n\")), mdx(\"p\", null, \"Returns the current loop timestamp.\\nThe loop timestamp is refreshed on every iteration of the runtime's main loop.\\nA single iteration involves calling all ready coroutines and continues until all coroutines are either done or waiting for the completion of an asynchronous function.\"), mdx(\"p\", null, \"Within the same iteration, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"loop_timestamp()\"), \" will always return the same value.\"), mdx(\"h2\", {\n    \"id\": \"coroutines\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#coroutines\"\n  }, \"#\"), \"Coroutines\"), mdx(\"h3\", {\n    \"id\": \"type-coroutine\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-coroutine\"\n  }, \"#\"), \"type Coroutine\"), mdx(\"p\", null, \"Coroutines represents threads of execution within a single operating system thread.\\nCoroutines are created through the native API or by calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std.launch()\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-coroutinetoken\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-coroutinetoken\"\n  }, \"#\"), \"type CoroutineToken\"), mdx(\"h3\", {\n    \"id\": \"func-current_coroutine\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-current_coroutine\"\n  }, \"#\"), \"func current_coroutine\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func current_coroutine(): Coroutine;\\n\")), mdx(\"p\", null, \"Returns the current \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-coroutine\"\n  }, \"Coroutine\"), \" instance, i.e. the coroutine from which \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"current_coroutine()\"), \" was called.\"), mdx(\"h3\", {\n    \"id\": \"func-launch\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-launch\"\n  }, \"#\"), \"func launch\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func launch(fn: Function, args...: Value...): Coroutine;\\n\")), mdx(\"p\", null, \"Executes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fn(args...)\"), \" from within a new coroutine.\\nThe coroutine instance is returned by this function.\"), mdx(\"p\", null, \"TODO: Should we return a future instead?\"), mdx(\"h3\", {\n    \"id\": \"func-dispatch\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-dispatch\"\n  }, \"#\"), \"func dispatch\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func dispatch();\\n\")), mdx(\"p\", null, \"Dispatches to other ready coroutines.\\nThe current coroutine will resume execution after all other ready coroutines had the opportunity to run.\"), mdx(\"h3\", {\n    \"id\": \"func-coroutine_token\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-coroutine_token\"\n  }, \"#\"), \"func coroutine_token\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func coroutine_token(): CoroutineToken;\\n\")), mdx(\"p\", null, \"Returns a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-coroutinetoken\"\n  }, \"CoroutineToken\"), \" instance suitable for resuming the current coroutine.\\nCoroutine tokens are invalidated after the coroutine has been resumed again.\\nSee \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#func-yield_coroutine\"\n  }, \"yield_coroutine()\"), \" for an example.\"), mdx(\"p\", null, \"WARNING: This is a low level API designed to control the execution of a coroutine manually.\\nIt should only be used to create new asynchronous abstractions.\"), mdx(\"h3\", {\n    \"id\": \"func-yield_coroutine\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-yield_coroutine\"\n  }, \"#\"), \"func yield_coroutine\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func yield_coroutine();\\n\")), mdx(\"p\", null, \"Immediately pauses execution of the current coroutine.\\nExecution will only continue once the coroutine has been resumed via a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-coroutinetoken\"\n  }, \"CoroutineToken\"), \" previously obtained from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#func-coroutine_token\"\n  }, \"coroutine_token()\"), \".\"), mdx(\"p\", null, \"WARNING: This is a low level API designed to control the execution of a coroutine manually.\\nIt should only be used to create new asynchronous abstractions.\"), mdx(\"span\", {\n    className: \"caption\"\n  }, \"Example: a simple Mutex\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import std;\\n\\nexport func main() {\\n    const mutex = createMutex();\\n    const task = func(id) {\\n        for var i = 0; i < 3; i += 1 {\\n            mutex.lock();\\n            std.print(\\\"Hello from ${id}\\\");\\n            std.dispatch(); // Other coroutine can observe a locked mutex\\n            mutex.unlock();\\n        }\\n    };\\n\\n    std.launch(task, \\\"1\\\");\\n    std.launch(task, \\\"2\\\");\\n}\\n\\n// Creates a simplistic mutex that only supports two coroutines.\\nfunc createMutex() {\\n    // Coroutine token if another coroutine is already waiting.\\n    var waiter = null;\\n    var locked = false;\\n\\n    return (\\n        lock: func() {\\n            if locked {\\n                if waiter != null {\\n                    std.panic(\\\"Cannot support more than one waiter\\\");\\n                }\\n                // Wait until the other coroutine unlocks.\\n                waiter = std.coroutine_token();\\n                std.yield_coroutine();\\n            }\\n            // At this point, either the mutex wasn't initially locked\\n            // or yield_coroutine() returned, i.e. the other coroutine unlocked.\\n            assert(!locked);\\n            locked = true;\\n        },\\n        unlock: func() {\\n            if !locked {\\n                std.panic(\\\"Mutex was not locked\\\");\\n            }\\n            locked = false;\\n            if waiter {\\n                waiter.resume();\\n                waiter = null;\\n            }\\n            // Give other coroutines the opportunity to run\\n            std.dispatch();\\n        }\\n    );\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"error-handling\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#error-handling\"\n  }, \"#\"), \"Error handling\"), mdx(\"h3\", {\n    \"id\": \"type-result\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-result\"\n  }, \"#\"), \"type Result\"), mdx(\"p\", null, \"A result represents the result of an operation that may fail.\\nThe result type is the basic primitive type used in tiro's error handling facilities.\"), mdx(\"p\", null, \"Results may be in one of two states:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Success\"), \". Calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"result.value()\"), \" returns the result of the operation.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Failure\"), \". Calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"result.reason()\"), \" returns a value explaining why the operation failed.\"))), mdx(\"p\", null, \"Results are constructed by calling the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#func-success\"\n  }, \"success()\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#func-failure\"\n  }, \"failure()\"), \" functions.\"), mdx(\"span\", {\n    className: \"caption\"\n  }, \"Example: simple error handling\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import std;\\n\\nexport func main() {\\n    const result1 = operation(5);\\n    std.print(result1.type(), result1.value()); // #success 10\\n\\n    const result2 = operation(-5);\\n    std.print(result2.type(), result2.reason()); // #failure value too small!\\n}\\n\\nfunc operation(n) {\\n     if (n < 0) {\\n        return std.failure(\\\"value too small!\\\");\\n    } else {\\n        return std.success(n * 2);\\n    }\\n}\\n\")), mdx(\"h4\", {\n    \"id\": \"func-resulttype\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-resulttype\"\n  }, \"#\"), \"func Result.type\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Result.type(): Symbol;\\n\")), mdx(\"p\", null, \"Returns either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#success\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#failure\"), \", depending on the result's state.\"), mdx(\"h4\", {\n    \"id\": \"func-resultis_success\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-resultis_success\"\n  }, \"#\"), \"func Result.is_success\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Result.is_success(): Boolean;\\n\")), mdx(\"p\", null, \"Returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" if the result represents success, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" otherwise.\"), mdx(\"h4\", {\n    \"id\": \"func-resultis_failure\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-resultis_failure\"\n  }, \"#\"), \"func Result.is_failure\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Result.is_failure(): Boolean;\\n\")), mdx(\"p\", null, \"Returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" if the result represents failure, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" otherwise.\"), mdx(\"h4\", {\n    \"id\": \"func-resultvalue\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-resultvalue\"\n  }, \"#\"), \"func Result.value\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Result.value(): Value;\\n\")), mdx(\"p\", null, \"Returns the result's value.\\nRequires that the result represents success.\"), mdx(\"h4\", {\n    \"id\": \"func-resultreason\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-resultreason\"\n  }, \"#\"), \"func Result.reason\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Result.reason(): Value;\\n\")), mdx(\"p\", null, \"Returns the result's reason.\\nRequires that the result represents failure.\"), mdx(\"h3\", {\n    \"id\": \"func-success\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-success\"\n  }, \"#\"), \"func success\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func success(value: Value): Result;\\n\")), mdx(\"p\", null, \"Returns a new successful \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-result\"\n  }, \"Result\"), \" that holds the given \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \".\"), mdx(\"h3\", {\n    \"id\": \"func-failure\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-failure\"\n  }, \"#\"), \"func failure\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func failure(reason: value): Result;\\n\")), mdx(\"p\", null, \"Returns a new failure \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-result\"\n  }, \"Result\"), \" that holds the given \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reason\"), \".\"), mdx(\"h3\", {\n    \"id\": \"type-exception\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#type-exception\"\n  }, \"#\"), \"type Exception\"), mdx(\"p\", null, \"Exceptions represent unexpected (and often fatal) errors encountered during program execution.\\nThey are generated when code panics, for example by calling \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#func-panic\"\n  }, \"panic()\"), \".\"), mdx(\"p\", null, \"It is often preferable to use the less intrusive \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-result\"\n  }, \"Result\"), \" type instead.\\nPanicking should be reserved for signaling critical error conditions such as programming errors.\"), mdx(\"p\", null, \"TODO: Other properties (stack trace, user data, secondary exceptions)\"), mdx(\"h4\", {\n    \"id\": \"func-exceptionmessage\"\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-exceptionmessage\"\n  }, \"#\"), \"func Exception.message\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func Exception.message(): String;\\n\")), mdx(\"p\", null, \"Returns the exception's error message.\"), mdx(\"h3\", {\n    \"id\": \"func-panic\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-panic\"\n  }, \"#\"), \"func panic\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func panic(message: String);\\n\")), mdx(\"p\", null, \"Immediately aborts execution of the current function with an error explained by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"message\"), \".\\nFrom within the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"panic\"), \" function, a new \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-exception\"\n  }, \"Exception\"), \" is constructed with the given \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"message\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Call_stack#Unwinding\"\n  }, \"stack unwinding\"), \" is started.\\nUnwinding can be stopped by using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#func-catch_panic\"\n  }, \"catch_panic\"), \" function.\"), mdx(\"p\", null, \"This function is designed to report \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unexpected\"), \" errors such as programming errors.\\nUse the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-result\"\n  }, \"Result\"), \" type instead if errors can be expected, e.g. to report missing files.\"), mdx(\"h3\", {\n    \"id\": \"func-catch_panic\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"className\": \"anchor-link\",\n    \"href\": \"#func-catch_panic\"\n  }, \"#\"), \"func catch_panic\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"func catch_panic(fn: Function): Result;\\n\")), mdx(\"p\", null, \"Invokes \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fn()\"), \" and stops propagation of any non-fatal panic thrown by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fn\"), \" or its callees.\\nAfter execution of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fn()\"), \" completes (either through panic or through normal return), a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#type-result\"\n  }, \"Result\"), \" is returned:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fn\"), \" returned normally, its return value is wrapped into a success result and returned.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If a panic was caught, a failure result is returned. The result's \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reason\"), \" is set to the caught value.\")), mdx(\"span\", {\n    className: \"caption\"\n  }, \"Example: catching a panic from a function\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import std;\\n\\nexport func main() {\\n    const result = std.catch_panic(may_fail);\\n    if (result.is_success()) {\\n        std.print(\\\"success:\\\", result.value());\\n    } else {\\n        std.print(\\\"failure:\\\", result.reason().message());\\n    }\\n}\\n\\nfunc may_fail() {\\n    // Replace `false` with `true` to return normally\\n    if (false) {\\n        return 42;\\n    } else {\\n        std.panic(\\\"help!\\\");\\n    }\\n}\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h1 id=\"the-standard-library\"><a class=\"anchor-link\" href=\"#the-standard-library\">#</a>The standard library</h1><p>Basic types and functions provided by the runtime.</p><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">import std;</span></div></pre></div><h2 id=\"contents\"><a class=\"anchor-link\" href=\"#contents\">#</a>Contents</h2><ul><li><p><a href=\"#basic-types-and-functions\">Basic types and functions</a></p><ul><li><a href=\"#type-boolean\">type Boolean</a></li><li><a href=\"#type-integer\">type Integer</a></li><li><a href=\"#type-float\">type Float</a></li><li><a href=\"#type-null\">type Null</a></li><li><a href=\"#type-string\">type String</a></li><li><a href=\"#type-symbol\">type Symbol</a></li><li><a href=\"#type-function\">type Function</a></li><li><a href=\"#type-module\">type Module</a></li><li><a href=\"#type-nativeobject\">type NativeObject</a></li><li><a href=\"#type-nativepointer\">type NativePointer</a></li><li><a href=\"#type-type\">type Type</a></li><li><a href=\"#func-type_of\">func type_of</a></li></ul></li><li><p><a href=\"#containers\">Containers</a></p><ul><li><a href=\"#type-tuple\">type Tuple</a></li><li><a href=\"#type-record\">type Record</a></li><li><a href=\"#type-array\">type Array</a></li><li><a href=\"#type-buffer\">type Buffer</a></li><li><a href=\"#type-map\">type Map</a></li><li><a href=\"#type-set\">type Set</a></li></ul></li><li><p><a href=\"#strings\">Strings</a></p><ul><li><a href=\"#type-stringslice\">type StringSlice</a></li><li><a href=\"#type-stringbuilder\">type StringBuilder</a></li><li><a href=\"#func-new_string_builder\">func new_string_builder</a></li></ul></li><li><p><a href=\"#input-and-output\">Input and Output</a></p><ul><li><a href=\"#func-print\">func print</a></li><li><a href=\"#func-loop_timestamp\">func loop_timestamp</a></li></ul></li><li><p><a href=\"#coroutines\">Coroutines</a></p><ul><li><a href=\"#type-coroutine\">type Coroutine</a></li><li><a href=\"#type-coroutinetoken\">type CoroutineToken</a></li><li><a href=\"#func-current_coroutine\">func current_coroutine</a></li><li><a href=\"#func-launch\">func launch</a></li><li><a href=\"#func-dispatch\">func dispatch</a></li><li><a href=\"#func-coroutine_token\">func coroutine_token</a></li><li><a href=\"#func-yield_coroutine\">func yield_coroutine</a></li></ul></li><li><p><a href=\"#error-handling\">Error handling</a></p><ul><li><a href=\"#type-result\">type Result</a></li><li><a href=\"#func-success\">func success</a></li><li><a href=\"#func-failure\">func failure</a></li><li><a href=\"#type-exception\">type Exception</a></li><li><a href=\"#func-panic\">func panic</a></li><li><a href=\"#func-catch_panic\">func catch_panic</a></li></ul></li></ul><h2 id=\"basic-types-and-functions\"><a class=\"anchor-link\" href=\"#basic-types-and-functions\">#</a>Basic types and functions</h2><h3 id=\"type-boolean\"><a class=\"anchor-link\" href=\"#type-boolean\">#</a>type Boolean</h3><p>The type of <code>true</code> and <code>false</code>.</p><h3 id=\"type-integer\"><a class=\"anchor-link\" href=\"#type-integer\">#</a>type Integer</h3><p>The type of integer expressions such as <code>7</code> or <code>0x1F</code>.</p><h3 id=\"type-float\"><a class=\"anchor-link\" href=\"#type-float\">#</a>type Float</h3><p>Type type of floating point expressions such as <code>1.25</code>.</p><h3 id=\"type-null\"><a class=\"anchor-link\" href=\"#type-null\">#</a>type Null</h3><p>The type of the constant <code>null</code>.</p><h3 id=\"type-string\"><a class=\"anchor-link\" href=\"#type-string\">#</a>type String</h3><p>The type of all string expressions.\nStrings are immutable.</p><p>TODO: Unicode strings</p><p>TODO: Internal representation is guaranteed to be UTF-8</p><h3 id=\"type-symbol\"><a class=\"anchor-link\" href=\"#type-symbol\">#</a>type Symbol</h3><p>The type of symbol literals, e.g. <code>#answer</code>.</p><h3 id=\"type-function\"><a class=\"anchor-link\" href=\"#type-function\">#</a>type Function</h3><p>The type of all functions.</p><h3 id=\"type-module\"><a class=\"anchor-link\" href=\"#type-module\">#</a>type Module</h3><p>The type of all modules:</p><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">import std;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">// std.type_of(std) == std.Module</span></div></pre></div><h3 id=\"type-nativeobject\"><a class=\"anchor-link\" href=\"#type-nativeobject\">#</a>type NativeObject</h3><p>The type of native objects that have been exposed to tiro.\nThe tiro runtime manages the lifetime (and the storage) of these objects, which usually includes invoking a native finalizer when the object is collected.</p><h3 id=\"type-nativepointer\"><a class=\"anchor-link\" href=\"#type-nativepointer\">#</a>type NativePointer</h3><p>The type of a native pointer that has been exposed to tiro.\nThe tiro runtime does <em>not</em> manage these objects in any way, which makes them very cheap to use.</p><h3 id=\"type-type\"><a class=\"anchor-link\" href=\"#type-type\">#</a>type Type</h3><p>The type of all types. In other words, <code>std.type_of(value)</code> will always return an instance of this type for any kind of value.</p><h3 id=\"func-type_of\"><a class=\"anchor-link\" href=\"#func-type_of\">#</a>func type_of</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func type_of(v: Value): Type;</span></div></pre></div><p>Returns the type of <code>v</code>. For example:</p><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">assert(std.type_of(true) == std.Boolean);</span></div></pre></div><h2 id=\"containers\"><a class=\"anchor-link\" href=\"#containers\">#</a>Containers</h2><h3 id=\"type-tuple\"><a class=\"anchor-link\" href=\"#type-tuple\">#</a>type Tuple</h3><p>The type of all tuples, e.g. <code>()</code>, <code>(1,)</code> or <code>(1, 2)</code>.</p><h3 id=\"type-record\"><a class=\"anchor-link\" href=\"#type-record\">#</a>type Record</h3><p>The type of all records, e.g. <code>(:)</code> or <code>(foo: &quot;bar&quot;)</code>.</p><h3 id=\"type-array\"><a class=\"anchor-link\" href=\"#type-array\">#</a>type Array</h3><p>The type of all arrays, e.g. <code>[]</code> and <code>[a, b, c]</code>.</p><p>An array is a dynamic sequence of items that can grow or shrink as needed.\nExisting items can be read or written using the indexing operator, e.g. <code>const first = array[0]</code> or <code>array[0] = &quot;first&quot;</code>.\nThe sequence of items can be manipulated using the methods below.</p><h4 id=\"func-arraysize\"><a class=\"anchor-link\" href=\"#func-arraysize\">#</a>func Array.size</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Array.size(): Integer;</span></div></pre></div><p>Returns the number of items in the array.</p><h4 id=\"func-arrayappend\"><a class=\"anchor-link\" href=\"#func-arrayappend\">#</a>func Array.append</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Array.append(v: Value);</span></div></pre></div><p>Appends <code>v</code> to the array.</p><h4 id=\"func-arrayclear\"><a class=\"anchor-link\" href=\"#func-arrayclear\">#</a>func Array.clear</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Array.clear()</span></div></pre></div><p>Removes all items from the array.</p><h3 id=\"type-buffer\"><a class=\"anchor-link\" href=\"#type-buffer\">#</a>type Buffer</h3><p>Buffers reference a raw region of memory, i.e. a blog of bytes.\nThey are especially useful when doing I/O or when manipulating large amounts of data.</p><p>TODO: usage</p><h4 id=\"func-buffersize\"><a class=\"anchor-link\" href=\"#func-buffersize\">#</a>func Buffer.size</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Buffer.size(): Integer;</span></div></pre></div><p>Returns the number of items in the buffer.</p><h3 id=\"type-map\"><a class=\"anchor-link\" href=\"#type-map\">#</a>type Map</h3><p>A map is a container that associates <em>keys</em> with <em>values</em>.\nThe key-value associations can be manipulated at will.\nGiven a key, a map allows for efficient lookup (and update) of the associated value.</p><p>Maps are implemented as <a href=\"https://en.wikipedia.org/wiki/Hash_table\" rel=\"noopener noreferrer\" target=\"_blank\"><span icon=\"share\" style=\"vertical-align:baseline;padding-right:4px\" class=\"bp3-icon bp3-icon-share\"><svg data-icon=\"share\" width=\"12\" height=\"12\" viewBox=\"0 0 16 16\"><desc>share</desc><path d=\"M10.99 13.99h-9v-9h4.76l2-2H.99c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h11c.55 0 1-.45 1-1V7.24l-2 2v4.75zm4-14h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L7.29 7.28a1 1 0 00-.3.71 1.003 1.003 0 001.71.71l5.29-5.29V6c0 .55.45 1 1 1s1-.45 1-1V1c0-.56-.45-1.01-1-1.01z\" fill-rule=\"evenodd\"></path></svg></span>hash tables</a>.</p><h4 id=\"map-insertion-order\"><a class=\"anchor-link\" href=\"#map-insertion-order\">#</a>Insertion order</h4><p>Contrary to most other hash table implementations, tiro&#x27;s map preserves the insertion order of its mappings.\nWhen iterating a map, keys and values are visited in the order in which they were inserted:</p><ul><li>A new key-value mapping (i.e. a key that was not already in the map) is always inserted at the end.</li><li>Updating an existing key-value mapping (i.e. key already exists in the map) does not change its order in the map.</li><li>Removing a key-value mapping preserves the order of all remaining mappings.</li></ul><span class=\"caption\">Example: iterating over a map</span><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">import std;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">export func main() {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    const m = map{};</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    m[1] = &quot;one&quot;;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    m[2] = &quot;two&quot;;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    m[3] = &quot;three&quot;;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    // Guaranteed output:</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    // 1 one</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    // 2 two</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    // 3 three</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    for (key, value) in m {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        std.print(key, value);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">}</span></div></pre></div><h4 id=\"func-mapsize\"><a class=\"anchor-link\" href=\"#func-mapsize\">#</a>func Map.size</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Map.size(): Integer;</span></div></pre></div><p>Returns the number of key-value mappings in the map.</p><h4 id=\"func-mapcontains\"><a class=\"anchor-link\" href=\"#func-mapcontains\">#</a>func Map.contains</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Map.contains(key: Value): Boolean;</span></div></pre></div><p>Returns <code>true</code> if there is a value associated with <code>key</code>, <code>false</code> otherwise.</p><h4 id=\"func-mapkeys\"><a class=\"anchor-link\" href=\"#func-mapkeys\">#</a>func Map.keys</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Map.keys(): Iterable;</span></div></pre></div><p>Returns an iterable view over the keys within the map.\nThe iteration order is the same as the map&#x27;s order.</p><h4 id=\"func-mapvalues\"><a class=\"anchor-link\" href=\"#func-mapvalues\">#</a>func Map.values</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Map.values(): Iterable;</span></div></pre></div><p>Returns an iterable view over the values within the map.\nThe iteration order is the same as the map&#x27;s order.</p><h4 id=\"func-mapclear\"><a class=\"anchor-link\" href=\"#func-mapclear\">#</a>func Map.clear</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Map.clear();</span></div></pre></div><p>Removes all key-value mappings from the map.</p><h4 id=\"func-mapremove\"><a class=\"anchor-link\" href=\"#func-mapremove\">#</a>func Map.remove</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Map.remove(key: Value);</span></div></pre></div><p>Removes the key-value mapping for <code>key</code>.\nDoes nothing if there is no such mapping.</p><p>TODO: Return true/false?</p><h3 id=\"type-set\"><a class=\"anchor-link\" href=\"#type-set\">#</a>type Set</h3><p>A set is a container that stores unique items.\nItems can be inserted or removed at will, and their existence can be tested efficiently.</p><p>Like maps, they are implemented as <a href=\"https://en.wikipedia.org/wiki/Hash_table\" rel=\"noopener noreferrer\" target=\"_blank\"><span icon=\"share\" style=\"vertical-align:baseline;padding-right:4px\" class=\"bp3-icon bp3-icon-share\"><svg data-icon=\"share\" width=\"12\" height=\"12\" viewBox=\"0 0 16 16\"><desc>share</desc><path d=\"M10.99 13.99h-9v-9h4.76l2-2H.99c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h11c.55 0 1-.45 1-1V7.24l-2 2v4.75zm4-14h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L7.29 7.28a1 1 0 00-.3.71 1.003 1.003 0 001.71.71l5.29-5.29V6c0 .55.45 1 1 1s1-.45 1-1V1c0-.56-.45-1.01-1-1.01z\" fill-rule=\"evenodd\"></path></svg></span>hash tables</a>.</p><h4 id=\"set-insertion-order\"><a class=\"anchor-link\" href=\"#set-insertion-order\">#</a>Insertion order</h4><p>When iterating a set, its items are visited in the order they were inserted in.\nSee also <a href=\"#map-insertion-order\">map insertion order</a>.</p><h4 id=\"func-setsize\"><a class=\"anchor-link\" href=\"#func-setsize\">#</a>func Set.size</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Set.size(): Integer;</span></div></pre></div><p>Returns the number of items in the set.</p><h4 id=\"func-setcontains\"><a class=\"anchor-link\" href=\"#func-setcontains\">#</a>func Set.contains</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Set.contains(item: Value): Boolean;</span></div></pre></div><p>Returns <code>true</code> if the set contains <code>item</code>, <code>false</code> otherwise.</p><h4 id=\"func-setclear\"><a class=\"anchor-link\" href=\"#func-setclear\">#</a>func Set.clear</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Set.clear();</span></div></pre></div><p>Removes all items from the set.</p><h4 id=\"func-setinsert\"><a class=\"anchor-link\" href=\"#func-setinsert\">#</a>func Set.insert</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Set.insert(item: Value): Boolean;</span></div></pre></div><p>Inserts <code>item</code> into the set.\nReturns <code>true</code> if item has been inserted, <code>false</code> if it already existed.</p><h4 id=\"func-setremove\"><a class=\"anchor-link\" href=\"#func-setremove\">#</a>func Set.remove</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Set.remove(item: Value);</span></div></pre></div><p>Removes <code>item</code> from the set.\nDoes nothing if <code>item</code> does not exist in the set.</p><p>TODO: Return true/false?</p><h2 id=\"strings\"><a class=\"anchor-link\" href=\"#strings\">#</a>Strings</h2><h3 id=\"type-stringslice\"><a class=\"anchor-link\" href=\"#type-stringslice\">#</a>type StringSlice</h3><h3 id=\"type-stringbuilder\"><a class=\"anchor-link\" href=\"#type-stringbuilder\">#</a>type StringBuilder</h3><h3 id=\"func-new_string_builder\"><a class=\"anchor-link\" href=\"#func-new_string_builder\">#</a>func new_string_builder</h3><h2 id=\"input-and-output\"><a class=\"anchor-link\" href=\"#input-and-output\">#</a>Input and Output</h2><h3 id=\"func-print\"><a class=\"anchor-link\" href=\"#func-print\">#</a>func print</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func print(values...: Value...);</span></div></pre></div><p>Prints the given values followed by a new line.</p><h3 id=\"func-loop_timestamp\"><a class=\"anchor-link\" href=\"#func-loop_timestamp\">#</a>func loop_timestamp</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func loop_timestamp(): Integer;</span></div></pre></div><p>Returns the current loop timestamp.\nThe loop timestamp is refreshed on every iteration of the runtime&#x27;s main loop.\nA single iteration involves calling all ready coroutines and continues until all coroutines are either done or waiting for the completion of an asynchronous function.</p><p>Within the same iteration, <code>loop_timestamp()</code> will always return the same value.</p><h2 id=\"coroutines\"><a class=\"anchor-link\" href=\"#coroutines\">#</a>Coroutines</h2><h3 id=\"type-coroutine\"><a class=\"anchor-link\" href=\"#type-coroutine\">#</a>type Coroutine</h3><p>Coroutines represents threads of execution within a single operating system thread.\nCoroutines are created through the native API or by calling <code>std.launch()</code>.</p><h3 id=\"type-coroutinetoken\"><a class=\"anchor-link\" href=\"#type-coroutinetoken\">#</a>type CoroutineToken</h3><h3 id=\"func-current_coroutine\"><a class=\"anchor-link\" href=\"#func-current_coroutine\">#</a>func current_coroutine</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func current_coroutine(): Coroutine;</span></div></pre></div><p>Returns the current <a href=\"#type-coroutine\">Coroutine</a> instance, i.e. the coroutine from which <code>current_coroutine()</code> was called.</p><h3 id=\"func-launch\"><a class=\"anchor-link\" href=\"#func-launch\">#</a>func launch</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func launch(fn: Function, args...: Value...): Coroutine;</span></div></pre></div><p>Executes <code>fn(args...)</code> from within a new coroutine.\nThe coroutine instance is returned by this function.</p><p>TODO: Should we return a future instead?</p><h3 id=\"func-dispatch\"><a class=\"anchor-link\" href=\"#func-dispatch\">#</a>func dispatch</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func dispatch();</span></div></pre></div><p>Dispatches to other ready coroutines.\nThe current coroutine will resume execution after all other ready coroutines had the opportunity to run.</p><h3 id=\"func-coroutine_token\"><a class=\"anchor-link\" href=\"#func-coroutine_token\">#</a>func coroutine_token</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func coroutine_token(): CoroutineToken;</span></div></pre></div><p>Returns a <a href=\"#type-coroutinetoken\">CoroutineToken</a> instance suitable for resuming the current coroutine.\nCoroutine tokens are invalidated after the coroutine has been resumed again.\nSee <a href=\"#func-yield_coroutine\">yield_coroutine()</a> for an example.</p><p>WARNING: This is a low level API designed to control the execution of a coroutine manually.\nIt should only be used to create new asynchronous abstractions.</p><h3 id=\"func-yield_coroutine\"><a class=\"anchor-link\" href=\"#func-yield_coroutine\">#</a>func yield_coroutine</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func yield_coroutine();</span></div></pre></div><p>Immediately pauses execution of the current coroutine.\nExecution will only continue once the coroutine has been resumed via a <a href=\"#type-coroutinetoken\">CoroutineToken</a> previously obtained from <a href=\"#func-coroutine_token\">coroutine_token()</a>.</p><p>WARNING: This is a low level API designed to control the execution of a coroutine manually.\nIt should only be used to create new asynchronous abstractions.</p><span class=\"caption\">Example: a simple Mutex</span><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">import std;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">export func main() {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    const mutex = createMutex();</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    const task = func(id) {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        for var i = 0; i &lt; 3; i += 1 {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            mutex.lock();</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            std.print(&quot;Hello from ${id}&quot;);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            std.dispatch(); // Other coroutine can observe a locked mutex</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            mutex.unlock();</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    };</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    std.launch(task, &quot;1&quot;);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    std.launch(task, &quot;2&quot;);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">}</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">// Creates a simplistic mutex that only supports two coroutines.</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func createMutex() {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    // Coroutine token if another coroutine is already waiting.</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    var waiter = null;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    var locked = false;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    return (</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        lock: func() {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            if locked {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                if waiter != null {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                    std.panic(&quot;Cannot support more than one waiter&quot;);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                // Wait until the other coroutine unlocks.</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                waiter = std.coroutine_token();</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                std.yield_coroutine();</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            // At this point, either the mutex wasn&#x27;t initially locked</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            // or yield_coroutine() returned, i.e. the other coroutine unlocked.</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            assert(!locked);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            locked = true;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        },</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        unlock: func() {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            if !locked {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                std.panic(&quot;Mutex was not locked&quot;);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            locked = false;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            if waiter {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                waiter.resume();</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">                waiter = null;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            // Give other coroutines the opportunity to run</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">            std.dispatch();</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    );</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">}</span></div></pre></div><h2 id=\"error-handling\"><a class=\"anchor-link\" href=\"#error-handling\">#</a>Error handling</h2><h3 id=\"type-result\"><a class=\"anchor-link\" href=\"#type-result\">#</a>type Result</h3><p>A result represents the result of an operation that may fail.\nThe result type is the basic primitive type used in tiro&#x27;s error handling facilities.</p><p>Results may be in one of two states:</p><ul><li><p><em>Success</em>. Calling <code>result.value()</code> returns the result of the operation.</p></li><li><p><em>Failure</em>. Calling <code>result.reason()</code> returns a value explaining why the operation failed.</p></li></ul><p>Results are constructed by calling the <a href=\"#func-success\">success()</a> and <a href=\"#func-failure\">failure()</a> functions.</p><span class=\"caption\">Example: simple error handling</span><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">import std;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">export func main() {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    const result1 = operation(5);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    std.print(result1.type(), result1.value()); // #success 10</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    const result2 = operation(-5);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    std.print(result2.type(), result2.reason()); // #failure value too small!</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">}</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func operation(n) {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">     if (n &lt; 0) {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        return std.failure(&quot;value too small!&quot;);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    } else {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        return std.success(n * 2);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">}</span></div></pre></div><h4 id=\"func-resulttype\"><a class=\"anchor-link\" href=\"#func-resulttype\">#</a>func Result.type</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Result.type(): Symbol;</span></div></pre></div><p>Returns either <code>#success</code> or <code>#failure</code>, depending on the result&#x27;s state.</p><h4 id=\"func-resultis_success\"><a class=\"anchor-link\" href=\"#func-resultis_success\">#</a>func Result.is_success</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Result.is_success(): Boolean;</span></div></pre></div><p>Returns <code>true</code> if the result represents success, <code>false</code> otherwise.</p><h4 id=\"func-resultis_failure\"><a class=\"anchor-link\" href=\"#func-resultis_failure\">#</a>func Result.is_failure</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Result.is_failure(): Boolean;</span></div></pre></div><p>Returns <code>true</code> if the result represents failure, <code>false</code> otherwise.</p><h4 id=\"func-resultvalue\"><a class=\"anchor-link\" href=\"#func-resultvalue\">#</a>func Result.value</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Result.value(): Value;</span></div></pre></div><p>Returns the result&#x27;s value.\nRequires that the result represents success.</p><h4 id=\"func-resultreason\"><a class=\"anchor-link\" href=\"#func-resultreason\">#</a>func Result.reason</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Result.reason(): Value;</span></div></pre></div><p>Returns the result&#x27;s reason.\nRequires that the result represents failure.</p><h3 id=\"func-success\"><a class=\"anchor-link\" href=\"#func-success\">#</a>func success</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func success(value: Value): Result;</span></div></pre></div><p>Returns a new successful <a href=\"#type-result\">Result</a> that holds the given <code>value</code>.</p><h3 id=\"func-failure\"><a class=\"anchor-link\" href=\"#func-failure\">#</a>func failure</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func failure(reason: value): Result;</span></div></pre></div><p>Returns a new failure <a href=\"#type-result\">Result</a> that holds the given <code>reason</code>.</p><h3 id=\"type-exception\"><a class=\"anchor-link\" href=\"#type-exception\">#</a>type Exception</h3><p>Exceptions represent unexpected (and often fatal) errors encountered during program execution.\nThey are generated when code panics, for example by calling <a href=\"#func-panic\">panic()</a>.</p><p>It is often preferable to use the less intrusive <a href=\"#type-result\">Result</a> type instead.\nPanicking should be reserved for signaling critical error conditions such as programming errors.</p><p>TODO: Other properties (stack trace, user data, secondary exceptions)</p><h4 id=\"func-exceptionmessage\"><a class=\"anchor-link\" href=\"#func-exceptionmessage\">#</a>func Exception.message</h4><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func Exception.message(): String;</span></div></pre></div><p>Returns the exception&#x27;s error message.</p><h3 id=\"func-panic\"><a class=\"anchor-link\" href=\"#func-panic\">#</a>func panic</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func panic(message: String);</span></div></pre></div><p>Immediately aborts execution of the current function with an error explained by <code>message</code>.\nFrom within the <code>panic</code> function, a new <a href=\"#type-exception\">Exception</a> is constructed with the given <code>message</code> and <a href=\"https://en.wikipedia.org/wiki/Call_stack#Unwinding\" rel=\"noopener noreferrer\" target=\"_blank\"><span icon=\"share\" style=\"vertical-align:baseline;padding-right:4px\" class=\"bp3-icon bp3-icon-share\"><svg data-icon=\"share\" width=\"12\" height=\"12\" viewBox=\"0 0 16 16\"><desc>share</desc><path d=\"M10.99 13.99h-9v-9h4.76l2-2H.99c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h11c.55 0 1-.45 1-1V7.24l-2 2v4.75zm4-14h-5c-.55 0-1 .45-1 1s.45 1 1 1h2.59L7.29 7.28a1 1 0 00-.3.71 1.003 1.003 0 001.71.71l5.29-5.29V6c0 .55.45 1 1 1s1-.45 1-1V1c0-.56-.45-1.01-1-1.01z\" fill-rule=\"evenodd\"></path></svg></span>stack unwinding</a> is started.\nUnwinding can be stopped by using the <a href=\"#func-catch_panic\">catch_panic</a> function.</p><p>This function is designed to report <em>unexpected</em> errors such as programming errors.\nUse the <a href=\"#type-result\">Result</a> type instead if errors can be expected, e.g. to report missing files.</p><h3 id=\"func-catch_panic\"><a class=\"anchor-link\" href=\"#func-catch_panic\">#</a>func catch_panic</h3><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func catch_panic(fn: Function): Result;</span></div></pre></div><p>Invokes <code>fn()</code> and stops propagation of any non-fatal panic thrown by <code>fn</code> or its callees.\nAfter execution of <code>fn()</code> completes (either through panic or through normal return), a <a href=\"#type-result\">Result</a> is returned:</p><ul><li>If <code>fn</code> returned normally, its return value is wrapped into a success result and returned.</li><li>If a panic was caught, a failure result is returned. The result&#x27;s <code>reason</code> is set to the caught value.</li></ul><span class=\"caption\">Example: catching a panic from a function</span><div><pre class=\"prism-code language-plain\" style=\"color:rgb(36, 41, 46);background-color:#f6f8fa;padding:10px\"><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">import std;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">export func main() {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    const result = std.catch_panic(may_fail);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    if (result.is_success()) {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        std.print(&quot;success:&quot;, result.value());</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    } else {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        std.print(&quot;failure:&quot;, result.reason().message());</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">}</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\" style=\"display:inline-block\">\n</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">func may_fail() {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    // Replace `false` with `true` to return normally</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    if (false) {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        return 42;</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    } else {</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">        std.panic(&quot;help!&quot;);</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">    }</span></div><div class=\"token-line\" style=\"color:rgb(36, 41, 46)\"><span class=\"token plain\">}</span></div></pre></div>","scope":{}}},"__N_SSG":true}