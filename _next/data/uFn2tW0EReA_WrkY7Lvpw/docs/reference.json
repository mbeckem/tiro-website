{"pageProps":{"slug":"reference","frontMatter":{"title":"Reference Documentation","slug":"/reference"},"mdx":{"compiledSource":"var d=Object.defineProperty,c=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var l=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable;var o=(t,n,a)=>n in t?d(t,n,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[n]=a,e=(t,n)=>{for(var a in n||(n={}))l.call(n,a)&&o(t,a,n[a]);if(r)for(var a of r(n))p.call(n,a)&&o(t,a,n[a]);return t},m=(t,n)=>c(t,u(n));var s=(t,n)=>{var a={};for(var i in t)l.call(t,i)&&n.indexOf(i)<0&&(a[i]=t[i]);if(t!=null&&r)for(var i of r(t))n.indexOf(i)<0&&p.call(t,i)&&(a[i]=t[i]);return a};const makeShortcode=t=>function(a){return console.warn(\"Component \"+t+\" was not imported, exported, or provided by MDXProvider as global scope\"),mdx(\"div\",e({},a))},Info=makeShortcode(\"Info\"),Rules=makeShortcode(\"Rules\"),Rule=makeShortcode(\"Rule\"),ItemTable=makeShortcode(\"ItemTable\"),Todo=makeShortcode(\"Todo\"),layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var i=a,{components:t}=i,n=s(i,[\"components\"]);return mdx(MDXLayout,m(e(e({},layoutProps),n),{components:t,mdxType:\"MDXLayout\"}),mdx(\"h1\",e({},{id:\"tiro-reference-documentation\"}),mdx(\"a\",e({parentName:\"h1\"},{className:\"anchor-link\",href:\"#tiro-reference-documentation\"}),\"\\xA7\"),\"Tiro Reference Documentation\"),mdx(\"h2\",e({},{id:\"basics\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"anchor-link\",href:\"#basics\"}),\"\\xA7\"),\"Basics\"),mdx(\"p\",null,`Tiro accepts UTF-8 encoded source files as input.\nSource files must conform to the rules outlined in this document to form a valid program.`),mdx(\"p\",null,\"This section describes the lexical structure of \",mdx(\"em\",{parentName:\"p\"},\"tokens\"),\" accepted by the language.\"),mdx(Info,{title:\"Note\",mdxType:\"Info\"},mdx(\"p\",null,\"Grammar rules in this section work on \",mdx(\"em\",{parentName:\"p\"},\"characters\"),`.\nNo whitespace is not allowed unless it matches one of the required patterns.`)),mdx(\"h3\",e({},{id:\"whitespace\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#whitespace\"}),\"\\xA7\"),\"Whitespace\"),mdx(\"p\",null,\"Whitespace tokens consists of a sequence of characters having the \",mdx(\"em\",{parentName:\"p\"},\"Pattern_White_Space\"),\" Unicode property (see (see \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://unicode.org/reports/tr31\"}),\"Unicode\\xAE Standard Annex #31\"),`).\nWhitespace is not significant: its only use is to separate characters of adjacent tokens that would otherwise be parsed as a single token.`),mdx(\"h3\",e({},{id:\"comments\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#comments\"}),\"\\xA7\"),\"Comments\"),mdx(\"p\",null,`Comments are used to annotate source code, but they have no meaning of their own.\nThey are simply treated as whitespace.`),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"Comment\",definition:{type:\"choice\",children:[{type:\"nonterminal\",name:\"LineComment\"},{type:\"nonterminal\",name:\"BlockComment\"}]},mdxType:\"Rule\"}),mdx(Rule,{name:\"LineComment\",definition:[\"//\",{type:\"repeat\",child:[{type:\"not\",child:\"\\\\n\"}]}],mdxType:\"Rule\"}),mdx(Rule,{name:\"BlockComment\",definition:[\"/*\",{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"BlockComment\"},{type:\"repeat\",child:{type:\"not\",child:\"*/\"}}]}},\"*/\"],mdxType:\"Rule\"})),mdx(\"p\",null,\"Line comments are introduced by \",mdx(\"inlineCode\",{parentName:\"p\"},\"//\"),` and continue until the end of the line.\nBlock comments are delimited by `,mdx(\"inlineCode\",{parentName:\"p\"},\"/*\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"*/\"),\" and may be nested.\"),mdx(\"h3\",e({},{id:\"keywords\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#keywords\"}),\"\\xA7\"),\"Keywords\"),mdx(\"p\",null,\"The following words have special meaning in the Tiro programming language:\"),mdx(ItemTable,{columns:5,items:[\"assert\",\"break\",\"const\",\"continue\",\"defer\",\"else\",\"export\",\"false\",\"for\",\"func\",\"if\",\"import\",\"in\",\"null\",\"return\",\"true\",\"var\",\"while\"],mdxType:\"ItemTable\"}),mdx(\"h4\",e({},{id:\"reserved-keywords\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#reserved-keywords\"}),\"\\xA7\"),\"Reserved keywords\"),mdx(\"p\",null,\"The following keywords are reserved for future use:\"),mdx(ItemTable,{columns:5,items:[\"as\",\"catch\",\"class\",\"interface\",\"is\",\"package\",\"protocol\",\"scope\",\"struct\",\"switch\",\"throw\",\"try\",\"yield\"],mdxType:\"ItemTable\"}),mdx(\"h3\",e({},{id:\"identifiers\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#identifiers\"}),\"\\xA7\"),\"Identifiers\"),mdx(\"p\",null,`Identifiers are used to name items.\nThey consist of one or more identifier characters as defined by the `,mdx(\"em\",{parentName:\"p\"},\"XID_Start\"),\" and \",mdx(\"em\",{parentName:\"p\"},\"XID_Continue\"),\" Unicode properties (see \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://unicode.org/reports/tr31\"}),\"Unicode\\xAE Standard Annex #31\"),`).\nKeywords cannot be used as identifiers.`),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"Identifier\",definition:{type:\"note\",child:{type:\"nonterminal\",name:\"KeywordOrIdentifier\"},note:\"Excluding keywords\"},mdxType:\"Rule\"}),mdx(Rule,{name:\"KeywordOrIdentifier\",definition:[{type:\"choice\",children:[{type:\"nonterminal\",name:\"XID_Start\",undefined:!0},\"_\"]},{type:\"repeat\",child:{type:\"nonterminal\",name:\"XID_Continue\",undefined:!0}}],mdxType:\"Rule\"})),mdx(\"h3\",e({},{id:\"number-literals\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#number-literals\"}),\"\\xA7\"),\"Number literals\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"Integer\",definition:{type:\"choice\",children:[{type:\"nonterminal\",name:\"DecInteger\"},{type:\"nonterminal\",name:\"BinInteger\"},{type:\"nonterminal\",name:\"OctInteger\"},{type:\"nonterminal\",name:\"HexInteger\"}]},mdxType:\"Rule\"}),mdx(Rule,{name:\"DecInteger\",definition:[{type:\"nonterminal\",name:\"DecDigit\"},{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"DecDigit\"},\"_\"]}}],mdxType:\"Rule\"}),mdx(Rule,{name:\"BinInteger\",definition:[\"0b\",{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"BinDigit\"},\"_\"]}},{type:\"nonterminal\",name:\"BinDigit\"},{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"BinDigit\"},\"_\"]}}],mdxType:\"Rule\"}),mdx(Rule,{name:\"OctInteger\",definition:[\"0o\",{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"OctDigit\"},\"_\"]}},{type:\"nonterminal\",name:\"OctDigit\"},{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"OctDigit\"},\"_\"]}}],mdxType:\"Rule\"}),mdx(Rule,{name:\"HexInteger\",definition:[\"0x\",{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"HexDigit\"},\"_\"]}},{type:\"nonterminal\",name:\"HexDigit\"},{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"HexDigit\"},\"_\"]}}],mdxType:\"Rule\"}),mdx(Rule,{name:\"DecDigit\",definition:{type:\"range\",value:[\"0\",\"9\"]},mdxType:\"Rule\"}),mdx(Rule,{name:\"BinDigit\",definition:{type:\"choice\",children:[\"0\",\"1\"]},mdxType:\"Rule\"}),mdx(Rule,{name:\"OctDigit\",definition:{type:\"range\",value:[\"0\",\"7\"]},mdxType:\"Rule\"}),mdx(Rule,{name:\"HexDigit\",definition:{type:\"choice\",children:[{type:\"range\",value:[\"0\",\"9\"]},{type:\"range\",value:[\"a\",\"f\"]},{type:\"range\",value:[\"A\",\"F\"]}]},mdxType:\"Rule\"})),mdx(Todo,{mdxType:\"Todo\"},\"Document floating point numbers.\"),mdx(\"h3\",e({},{id:\"string-literals\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#string-literals\"}),\"\\xA7\"),\"String literals\"),mdx(\"p\",null,\"Strings are sequences of characters enclosed by matching quote characters (\",mdx(\"inlineCode\",{parentName:\"p\"},'\"'),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"'\"),`).\nWithin a string, variables can be interpolated when prefixed with a `,mdx(\"inlineCode\",{parentName:\"p\"},\"$\"),` sign and full expressions can be interpolated when enclosed within a\nblock started with `,mdx(\"inlineCode\",{parentName:\"p\"},\"${\"),\" and closed with a \",mdx(\"inlineCode\",{parentName:\"p\"},\"}\"),\" sign.\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"String\",definition:[{type:\"nonterminal\",name:\"StringDelimiter\"},{type:\"repeat\",child:{type:\"choice\",children:[{type:\"nonterminal\",name:\"PlainStringContent\"},{type:\"nonterminal\",name:\"EscapeSequence\"},{type:\"nonterminal\",name:\"InterpolatedValue\"}]}},{type:\"note\",child:{type:\"nonterminal\",name:\"StringDelimiter\"},note:\"matches starting delimiter\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"StringDelimiter\",definition:{type:\"choice\",children:['\"',\"'\"]},mdxType:\"Rule\"}),mdx(Rule,{name:\"PlainStringContent\",definition:{type:\"repeat\",child:{type:\"not\",child:{type:\"choice\",children:[\"\\\\\",\"$\",{type:\"note\",child:{type:\"nonterminal\",name:\"StringDelimiter\"},note:\"matches starting delimiter\"}]}}},mdxType:\"Rule\"}),mdx(Rule,{name:\"InterpolatedValue\",definition:{type:\"choice\",children:[[\"$\",{type:\"nonterminal\",name:\"VarExpr\"}],[\"${\",{type:\"nonterminal\",name:\"Expr\"},\"}\"]]},mdxType:\"Rule\"})),mdx(Todo,{mdxType:\"Todo\"},mdx(\"p\",null,\"Open design questions:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Should strings be multi line by default (current state)? Or should a \",mdx(\"inlineCode\",{parentName:\"li\"},\"\\\\\"),\" at the end of a line be necessary to continue to the following line?\"),mdx(\"li\",{parentName:\"ul\"},\"Should all strings support interpolation by default? Or provide a variant (e.g. delimited by \",mdx(\"inlineCode\",{parentName:\"li\"},\"'\"),\") that does \",mdx(\"em\",{parentName:\"li\"},\"not\"),\" support interpolation?\"),mdx(\"li\",{parentName:\"ul\"},\"Should all strings be guaranteed (required) to be valid UTF-8?\"))),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const greeting = \"Hello\";\n    std.print(\"$greeting \\${get_target()}!\");\n}\n\nfunc get_target() {\n    return \"World\";\n}\n`)),mdx(\"h4\",e({},{id:\"escape-sequences\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#escape-sequences\"}),\"\\xA7\"),\"Escape sequences\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"EscapeSequence\",definition:{type:\"choice\",children:[{type:\"nonterminal\",name:\"EscapedCharacter\"},{type:\"nonterminal\",name:\"AsciiEscape\"},{type:\"nonterminal\",name:\"UnicodeEscape\"}]},mdxType:\"Rule\"}),mdx(Rule,{name:\"EscapedCharacter\",definition:{type:\"choice\",children:[\"\\\\\\\\\",\"\\\\n\",\"\\\\r\",\"\\\\t\",'\\\\\"',\"\\\\'\",\"\\\\$\"]},mdxType:\"Rule\"}),mdx(Rule,{name:\"AsciiEscape\",definition:[\"\\\\x\",{type:\"nonterminal\",name:\"HexDigit\"},{type:\"nonterminal\",name:\"HexDigit\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"UnicodeEscape\",definition:[\"\\\\u{\",{type:\"repeat\",min:1,child:{type:\"nonterminal\",name:\"HexDigit\"}},\"}\"],mdxType:\"Rule\"})),mdx(\"p\",null,\"Escape sequences produce the following string content:\"),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Escape Sequence\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Production\"),mdx(\"th\",e({parentName:\"tr\"},{align:null})))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\\\\\\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Literal \",mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\n\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Newline\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\r\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Carriage return\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\t\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Tabulator\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},'\\\\\"')),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Literal \",mdx(\"inlineCode\",{parentName:\"td\"},'\"')),mdx(\"td\",e({parentName:\"tr\"},{align:null}))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\'\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Literal \",mdx(\"inlineCode\",{parentName:\"td\"},\"'\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\$\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Literal \",mdx(\"inlineCode\",{parentName:\"td\"},\"$\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\x\"),\" digits..\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"A single byte\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"The numeric value of the two hex digits is produced as a byte (TODO: Must be valid utf-8?)\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"\\\\u{\"),\" digits.. \",mdx(\"inlineCode\",{parentName:\"td\"},\"}\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"A single unicode code point\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"The sequence of hex digits is interpreted as the value of a unicode code point.\")))),mdx(\"h3\",e({},{id:\"symbol-literals\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#symbol-literals\"}),\"\\xA7\"),\"Symbol literals\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"Symbol\",definition:[\"#\",{type:\"nonterminal\",name:\"Identifier\"}],mdxType:\"Rule\"})),mdx(Todo,{mdxType:\"Todo\"},mdx(\"p\",null,\"Documentation\")),mdx(\"h2\",e({},{id:\"grammar\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"anchor-link\",href:\"#grammar\"}),\"\\xA7\"),\"Grammar\"),mdx(\"p\",null,\"This section describes higher level syntax constructions based on tokens.\"),mdx(Info,{title:\"Note\",mdxType:\"Info\"},mdx(\"p\",null,\"Grammar rules in this section work on \",mdx(\"em\",{parentName:\"p\"},\"tokens\"),`.\nAny amount of white space may appear between matching tokens.`)),mdx(\"h3\",e({},{id:\"items\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#items\"}),\"\\xA7\"),\"Items\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"File\",definition:{type:\"repeat\",child:{type:\"nonterminal\",name:\"Item\"}},mdxType:\"Rule\"}),mdx(Rule,{name:\"Item\",definition:[{type:\"optional\",child:\"export\"},{type:\"choice\",children:[[{type:\"nonterminal\",name:\"ImportDecl\"},\";\"],[{type:\"nonterminal\",name:\"VarDecl\"},\";\"],[{type:\"nonterminal\",name:\"FuncDecl\"}]]}],mdxType:\"Rule\"})),mdx(\"p\",null,\"A Tiro source file is a sequence of \",mdx(\"em\",{parentName:\"p\"},\"Items\"),`.\nAn item containing the `,mdx(\"inlineCode\",{parentName:\"p\"},\"export\"),` modifier will be exported from the current module.\nExported items are visible to other modules and may be imported.`),mdx(\"h4\",e({},{id:\"imports\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#imports\"}),\"\\xA7\"),\"Imports\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"ImportDecl\",definition:[\"import\",{type:\"nonterminal\",name:\"ImportPath\"},{type:\"optional\",child:[\"as\",{type:\"nonterminal\",name:\"Identifier\"}]}],mdxType:\"Rule\"}),mdx(Rule,{name:\"ImportPath\",definition:[{type:\"nonterminal\",name:\"Identifier\"},{type:\"repeat\",child:[\".\",{type:\"nonterminal\",name:\"Identifier\"}]}],mdxType:\"Rule\"})),mdx(\"p\",null,\"An \",mdx(\"inlineCode\",{parentName:\"p\"},\"import\"),\" item imports the module referenced by the \",mdx(\"em\",{parentName:\"p\"},\"ImportPath\"),` and introduces it into the current scope.\nThe last `,mdx(\"em\",{parentName:\"p\"},\"Identifier\"),\" in the \",mdx(\"em\",{parentName:\"p\"},\"ImportPath\"),` serves as the name of the imported reference by default.\nA custom name may be provided by using the `,mdx(\"inlineCode\",{parentName:\"p\"},\"as\"),\" keyword.\"),mdx(Todo,{mdxType:\"Todo\"},mdx(\"p\",null,`The import path must currently point to a module.\nIt should also allow for entities within a module.`),mdx(\"p\",null,\"For example, \",mdx(\"inlineCode\",{parentName:\"p\"},\"import std.print as myprint\"),\" should be valid.\"),mdx(\"p\",null,\"Grouping imports should be possible, for example \",mdx(\"inlineCode\",{parentName:\"p\"},\"import std { print, PI as MY_PI}\"),\".\")),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    std.print(\"Hello World\");\n}\n`)),mdx(\"h4\",e({},{id:\"variables\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#variables\"}),\"\\xA7\"),\"Variables\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"VarDecl\",definition:[{type:\"choice\",children:[\"const\",\"var\"]},{type:\"nonterminal\",name:\"Binding\"},{type:\"repeat\",child:[\",\",{type:\"nonterminal\",name:\"Binding\"}]}],mdxType:\"Rule\"}),mdx(Rule,{name:\"Binding\",definition:[{type:\"nonterminal\",name:\"BindingPattern\"},{type:\"optional\",child:[\"=\",{type:\"nonterminal\",name:\"Expr\"}]}],mdxType:\"Rule\"}),mdx(Rule,{name:\"BindingPattern\",definition:{type:\"choice\",children:[{type:\"nonterminal\",name:\"Identifier\"},{type:\"nonterminal\",name:\"TupleBindingPattern\"}]},mdxType:\"Rule\"}),mdx(Rule,{name:\"TupleBindingPattern\",definition:[\"(\",{type:\"nonterminal\",name:\"Identifier\"},{type:\"repeat\",child:[\",\",{type:\"nonterminal\",name:\"Identifier\"}]},\")\"],mdxType:\"Rule\"})),mdx(\"p\",null,`Variable declarations introduce one or more variables into the current scope.\nA variable declaration contains `,mdx(\"em\",{parentName:\"p\"},\"Bindings\"),\", which may provide an initializer expression for the \",mdx(\"em\",{parentName:\"p\"},\"Identifier\"),\" or \",mdx(\"em\",{parentName:\"p\"},\"Identifiers\"),\" mentioned in the \",mdx(\"em\",{parentName:\"p\"},\"BindingPattern\"),\".\"),mdx(\"p\",null,\"Bindings introduce a single new variable when the \",mdx(\"em\",{parentName:\"p\"},\"BindingPattern\"),` consists of a single identifier.\nThe optional initializer expression may yield any value in this case.`),mdx(\"p\",null,\"A \",mdx(\"em\",{parentName:\"p\"},\"TupleBindingPattern\"),` introduces multiple variables at once.\nThe optional initializer for a tuple pattern must yield a tuple value with a compatible size (at least the number of declared variable names).`),mdx(\"p\",null,\"Using the \",mdx(\"inlineCode\",{parentName:\"p\"},\"var\"),\" keyword creates a mutable variable, while a variable declared using the \",mdx(\"inlineCode\",{parentName:\"p\"},\"const\"),` keyword cannot be reassigned after its initialization.\nConstants must have an initializer.`),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Declaration kind\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Example\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Meaning\"))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Simple declaration\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"var x;\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Declares the initialized variable \",mdx(\"em\",{parentName:\"td\"},\"x\"),\" in the current scope\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Multiple variables\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"var x, y;\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Declares \",mdx(\"em\",{parentName:\"td\"},\"x\"),\" and \",mdx(\"em\",{parentName:\"td\"},\"y\"),\" in the current scope\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"With initializer\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"var x = 3.14;\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Declares \",mdx(\"em\",{parentName:\"td\"},\"x\"),\" and with the initial value \",mdx(\"inlineCode\",{parentName:\"td\"},\"3.14\"))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Constant declaration\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"const x = 3.14; \")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Like the above, but \",mdx(\"em\",{parentName:\"td\"},\"x\"),\" cannot be reassigned anymore\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Tuple unpacking\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"inlineCode\",{parentName:\"td\"},\"var (x, y) = (1, 2);\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Unpacks the right hand side tuple into the new variables \",mdx(\"em\",{parentName:\"td\"},\"x\"),\" and \",mdx(\"em\",{parentName:\"td\"},\"y\"))))),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    var a = \"single variable\";\n    const b = 1, c = 2;\n    var (d, e) = (\"first\", \"second\");\n    std.print(a, b, c, d, e);\n}\n`)),mdx(\"h4\",e({},{id:\"functions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#functions\"}),\"\\xA7\"),\"Functions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"FuncDecl\",definition:[\"func\",{type:\"optional\",child:{type:\"nonterminal\",name:\"Identifier\"}},\"(\",{type:\"optional\",child:{type:\"nonterminal\",name:\"ParamList\"}},\")\",{type:\"nonterminal\",name:\"FuncBody\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"ParamList\",definition:[{type:\"nonterminal\",name:\"Identifier\"},{type:\"repeat\",child:[\",\",{type:\"nonterminal\",name:\"Identifier\"}]}],mdxType:\"Rule\"}),mdx(Rule,{name:\"FuncBody\",definition:{type:\"choice\",children:[[\"=\",{type:\"nonterminal\",name:\"Expr\"}],{type:\"nonterminal\",name:\"BlockExpr\"}]},mdxType:\"Rule\"})),mdx(\"p\",null,`A function declaration creates a new function.\nFunctions may have a name, a set of parameters and a body.\nWhen a function is `,mdx(\"em\",{parentName:\"p\"},\"invoked\"),\", values passed as arguments in the function call expression will be bound to the declared parameters of that function.\"),mdx(\"p\",null,\"The body of a function may be specified as either a \",mdx(\"em\",{parentName:\"p\"},\"BlockExpr\"),\" or as a single expression introduced by a \",mdx(\"inlineCode\",{parentName:\"p\"},\"=\"),` sign.\nThe shorthand syntax is useful for very simple functions.`),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    std.print(block_body(1));\n    std.print(shorthand_body(2));\n}\n\nfunc block_body(p) {\n    const result = p * 2;\n    return result;\n}\n\nfunc shorthand_body(p) = p * 2;\n`)),mdx(Todo,{mdxType:\"Todo\"},mdx(\"p\",null,\"Open design question: Use \",mdx(\"inlineCode\",{parentName:\"p\"},\"->\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"=>\"),\" instead of the plain \",mdx(\"inlineCode\",{parentName:\"p\"},\"=\"),\" in the shorthand syntax?\")),mdx(\"h3\",e({},{id:\"statements\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#statements\"}),\"\\xA7\"),\"Statements\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"Stmt\",definition:{type:\"choice\",children:[[{type:\"nonterminal\",name:\"VarDecl\"},\";\"],[{type:\"nonterminal\",name:\"AssertStmt\"},\";\"],[{type:\"nonterminal\",name:\"DeferStmt\"},\";\"],[{type:\"nonterminal\",name:\"WhileStmt\"}],[{type:\"nonterminal\",name:\"ForEachStmt\"}],[{type:\"nonterminal\",name:\"ForStmt\"}],[{type:\"nonterminal\",name:\"IfExpr\"}],[{type:\"nonterminal\",name:\"BlockExpr\"}],[{type:\"nonterminal\",name:\"Expr\"},\";\"],\";\"]},mdxType:\"Rule\"})),mdx(\"p\",null,`Statements are constructs used in block expressions such as function bodies.\nMost statements must be terminated by a semicolon.\nThe semicolon is optional for block-like statements, where the end of the statement is obvious from the position of the closing `,mdx(\"inlineCode\",{parentName:\"p\"},\"}\"),\".\"),mdx(\"h4\",e({},{id:\"assertions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#assertions\"}),\"\\xA7\"),\"Assertions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"AssertStmt\",definition:[\"assert\",\"(\",{type:\"nonterminal\",name:\"Expr\"},{type:\"optional\",child:[\",\",{type:\"nonterminal\",name:\"String\"}]},\")\"],mdxType:\"Rule\"})),mdx(\"p\",null,`An assertion verifies that the expression yields a truthful value.\nA failed assertion results in a `,mdx(\"em\",{parentName:\"p\"},\"panic\"),\".\"),mdx(\"p\",null,\"An optional message argument may be specified; it will be included in the panic's diagnostic error message.\"),mdx(Info,{title:\"Note\",mdxType:\"Info\"},mdx(\"p\",null,`Assertions should be used to verify program invariants during development.\nThey may be disabled by compilation flags.\nDo not rely on their presence at runtime.\nMost importantly, avoid side effects inside assertions.`)),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`export func main() {\n    var n = 1;\n    assert(n % 2 == 0, \"n must be even!\"); // fails\n}\n`)),mdx(\"h4\",e({},{id:\"defer-statements\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#defer-statements\"}),\"\\xA7\"),\"Defer statements\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"DeferStmt\",definition:[\"defer\",{type:\"nonterminal\",name:\"Expr\"}],mdxType:\"Rule\"})),mdx(\"p\",null,`The defer statement registers an expression to be evaluated when the program leaves the current scope.\nIt's main use is to ensure that resources are cleaned up properly.`),mdx(\"p\",null,\"Defer statements that have been visited by the program will run even if the scope is being left abruptly, such as by an early \",mdx(\"inlineCode\",{parentName:\"p\"},\"return\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"break\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"continue\"),\" or a panic.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    std.print(\"acquire resource\");\n    defer std.print(\"release resource\");\n    std.print(\"use resource\");\n}\n`)),mdx(\"h4\",e({},{id:\"while-loops\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#while-loops\"}),\"\\xA7\"),\"While loops\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"WhileStmt\",definition:[\"while\",{type:\"note\",child:{type:\"nonterminal\",name:\"Expr\"},note:\"Excluding BlockExpr\"},{type:\"nonterminal\",name:\"BlockExpr\"}],mdxType:\"Rule\"}),mdx(\"p\",null,`A while loop consists of a condition expression and a loop body.\nThe condition will be repeatedly evaluated, and while it is truthful, the loop body will also be executed.\nThe loop's execution stops as soon as the condition is false.`),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    var i = 0;\n    while i < 3 {\n        std.print(i);\n        i += 1;\n    }\n    std.print(\"done\");\n}\n`))),mdx(\"h4\",e({},{id:\"for-each-loops\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#for-each-loops\"}),\"\\xA7\"),\"For-each loops\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"ForEachStmt\",definition:[\"for\",{type:\"nonterminal\",name:\"BindingPattern\"},\"in\",{type:\"note\",child:{type:\"nonterminal\",name:\"Expr\"},note:\"Excluding BlockExpr\"},{type:\"nonterminal\",name:\"BlockExpr\"}],mdxType:\"Rule\"})),mdx(\"p\",null,`The for-each loop allows iteration over a collection or sequence such as an array.\nIt requires a `,mdx(\"em\",{parentName:\"p\"},\"BindingPattern\"),\" that specifies the variable names used for iteration and an expression that yields an iterable sequence.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const numbers = [1, 2, 3];\n    for c in numbers {\n        std.print(c);\n    }\n\n    const constants = map{\n        \"pi\": 3.14,\n        \"e\": 2.72\n    };\n    for (name, value) in constants {\n        std.print(\"$name = $value\");\n    }\n}\n`)),mdx(\"h4\",e({},{id:\"classic-for-loops\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#classic-for-loops\"}),\"\\xA7\"),\"Classic for loops\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"ForStmt\",definition:[\"for\",{type:\"note\",child:[{type:\"optional\",child:{type:\"nonterminal\",name:\"VarDecl\"}},\";\",{type:\"optional\",child:{type:\"nonterminal\",name:\"Expr\"}},\";\",{type:\"optional\",child:{type:\"nonterminal\",name:\"Expr\"}}],note:\"Excluding BlockExpr\"},{type:\"nonterminal\",name:\"BlockExpr\"}],mdxType:\"Rule\"})),mdx(\"p\",null,\"The classic for loop allows iteration using one or more control variables, a condition expression and an update step.\"),mdx(\"p\",null,\"When the loop starts its execution, the optional control variables are defined and possibly initialized.\"),mdx(\"p\",null,`Before every iteration, the optional condition expression is evaluated, and if it is truthful, the loop body is executed.\nIf the condition is false, loop execution stops.\nIf the condition is not defined, it is implicitly truthful.`),mdx(\"p\",null,\"The optional update expression is evaluated after every completed loop iteration.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    for var i = 0; i < 3; i += 1 {\n        std.print(i);\n    }\n}\n`)),mdx(\"h3\",e({},{id:\"expressions\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#expressions\"}),\"\\xA7\"),\"Expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"Expr\",definition:{type:\"choice\",children:[{type:\"nonterminal\",name:\"VarExpr\"},{type:\"nonterminal\",name:\"FieldExpr\"},{type:\"nonterminal\",name:\"TupleFieldExpr\"},{type:\"nonterminal\",name:\"IndexExpr\"},{type:\"nonterminal\",name:\"CallExpr\"},{type:\"nonterminal\",name:\"UnaryExpr\"},{type:\"nonterminal\",name:\"BinaryExpr\"},{type:\"nonterminal\",name:\"AssignExpr\"},{type:\"nonterminal\",name:\"ContinueExpr\"},{type:\"nonterminal\",name:\"BreakExpr\"},{type:\"nonterminal\",name:\"ReturnExpr\"},{type:\"nonterminal\",name:\"GroupedExpr\"},{type:\"nonterminal\",name:\"IfExpr\"},{type:\"nonterminal\",name:\"FuncExpr\"},{type:\"nonterminal\",name:\"BlockExpr\"}]},mdxType:\"Rule\"})),mdx(\"p\",null,`Expressions are syntax constructs that yield a value.\nTiro is an expression-oriented language; most syntax constructions are expressions.`),mdx(Todo,{mdxType:\"Todo\"},mdx(\"p\",null,\"Open design question: should loops be expressions?\")),mdx(\"h4\",e({},{id:\"evaluation-order\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#evaluation-order\"}),\"\\xA7\"),\"Evaluation order\"),mdx(\"p\",null,\"All expressions are evaluated strictly from left to right.\"),mdx(\"h4\",e({},{id:\"variable-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#variable-expressions\"}),\"\\xA7\"),\"Variable expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"VarExpr\",definition:{type:\"nonterminal\",name:\"Identifier\"},mdxType:\"Rule\"})),mdx(\"p\",null,`A variable expression yields the current value of the variable identified by the given identifier.\nTiro is a lexically scoped language: variables may only be referenced from within the scope in which they have been defined.\nIf there are multiple variable declarations for the same identifier in scope, the closest variable declaration is referenced.`),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const x = 0;\n    {\n        const x = 1;\n        {\n            const x = 2;\n            std.print(x);\n        }\n        std.print(x);\n    }\n    std.print(x);\n}\n`)),mdx(\"h4\",e({},{id:\"field-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#field-expressions\"}),\"\\xA7\"),\"Field expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"FieldExpr\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"choice\",children:[\".\",\"?.\"]},{type:\"nonterminal\",name:\"Identifier\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"TupleFieldExpr\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"choice\",children:[\".\",\"?.\"]},{type:\"nonterminal\",name:\"NonNegativeInt\"}],mdxType:\"Rule\"})),mdx(\"p\",null,\"A field expression evaluates the expression left to the \",mdx(\"inlineCode\",{parentName:\"p\"},\".\"),\" symbol and yields the specified field of that value.\"),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"?.\"),` token can be used to make the field lookup optional.\nIf the left hand side is `,mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\", the field expression will also yield \",mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\".\"),mdx(\"p\",null,`The tuple field expression is a variant of the above that allows to lookup a tuple member instead.\nThe left hand side expression must yield a tuple value and the right hand side token must be a non negative integer.`),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const rec = (x: 1);\n    const no_rec = null;\n    std.print(rec.x);\n    std.print(rec?.x);\n    std.print(no_rec?.x);\n\n    const tuple = (1, 2);\n    const no_tuple = null;\n    std.print(tuple.1);\n    std.print(tuple?.1);\n    std.print(no_tuple?.1);\n}\n`)),mdx(\"h4\",e({},{id:\"index-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#index-expressions\"}),\"\\xA7\"),\"Index expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"IndexExpr\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"choice\",children:[\"[\",\"?[\"]},{type:\"nonterminal\",name:\"Expr\"},\"]\"],mdxType:\"Rule\"})),mdx(\"p\",null,\"Index expressions are used to lookup a value within a container by its index.\"),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"?[\"),` token can be used to make the value lookup optional.\nIf the left hand side is `,mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\", the index expression will also yield \",mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\" and the expression between brackets will not be evaluated.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const numbers = [1, 2, 3];\n    std.print(numbers[1]);\n\n    const constants = map{\n        \"pi\": 3.14,\n        \"e\": 2.72\n    };\n    std.print(constants[\"pi\"]);\n\n    const no_container = null;\n    std.print(no_container?[1]);\n}\n`)),mdx(\"h4\",e({},{id:\"call-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#call-expressions\"}),\"\\xA7\"),\"Call expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"CallExpr\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"choice\",children:[\"(\",\"?(\"]},{type:\"optional\",child:{type:\"nonterminal\",name:\"CallArguments\"}},\")\"],mdxType:\"Rule\"}),mdx(Rule,{name:\"CallArguments\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"repeat\",child:[\",\",{type:\"nonterminal\",name:\"Expr\"}]}],mdxType:\"Rule\"})),mdx(\"p\",null,\"A Call expression invokes a function with a set of arguments.\"),mdx(\"p\",null,`The first expression must yield a function.\nExpressions passed as arguments (between parentheses) will be evaluated, then control will be passed to function with all\narguments bound to the corresponding function parameter.\nThe call expression yields the return value of the invoked function.`),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"?(\"),` token can be used to make the function call optional.\nIf the function value yields `,mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\", the arguments will not be evaluated and the entire expression will also yield \",mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\".\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    std.print(add(1, 2));\n    std.print(add(4, 2 * 3));\n}\n\nfunc add(x, y) {\n    return x + y;\n}\n`)),mdx(\"h4\",e({},{id:\"unary-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#unary-expressions\"}),\"\\xA7\"),\"Unary expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"UnaryExpr\",definition:[{type:\"nonterminal\",name:\"UnaryOp\"},{type:\"nonterminal\",name:\"Expr\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"UnaryOp\",definition:{type:\"choice\",children:[\"+\",\"-\",\"!\",\"~\"]},mdxType:\"Rule\"})),mdx(\"p\",null,\"Unary expressions evaluate the right hand side expression and then apply the specified operator to its result.\"),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Operator\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Description\"))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"+\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Unary plus. Requires a number operand. Yields the number as-is.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"-\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Unary minus. Requires a number operand. Yields the arithmetic negative of its operand.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"!\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Unary NOT. Returns the logical negative of its operand: \",mdx(\"inlineCode\",{parentName:\"td\"},\"false\"),\" for all truthful values, \",mdx(\"inlineCode\",{parentName:\"td\"},\"true\"),\" otherwise.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"~\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Bitwise NOT. Requires an integer operand. Yields an integer with all bits inverted.\")))),mdx(\"h4\",e({},{id:\"binary-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#binary-expressions\"}),\"\\xA7\"),\"Binary expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"BinaryExpr\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"nonterminal\",name:\"BinaryOp\"},{type:\"nonterminal\",name:\"Expr\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"BinaryOp\",definition:{type:\"choice\",children:[\"+\",\"-\",\"*\",\"**\",\"/\",\"%\",\"&\",\"|\",\"<<\",\">>\",\"^\",\"==\",\"!=\",\"<\",\">\",\"<=\",\">=\",\"&&\",\"||\",\"??\"]},mdxType:\"Rule\"})),mdx(\"p\",null,\"Binary expressions apply an operation to the left hand and right hand side expressions.\"),mdx(\"h5\",e({},{id:\"arithmetic-operators\"}),mdx(\"a\",e({parentName:\"h5\"},{className:\"anchor-link\",href:\"#arithmetic-operators\"}),\"\\xA7\"),\"Arithmetic operators\"),mdx(\"p\",null,\"These operators require two numeric operands and apply the specified arithmetic operation on them.\"),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Operator\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Name\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Description\"))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" + \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Addition\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields the sum of \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" and \",mdx(\"em\",{parentName:\"td\"},\"b\"),\".\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" - \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Subtraction\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields the difference of \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" and \",mdx(\"em\",{parentName:\"td\"},\"b\"),\".\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" \",\"*\",\" \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Multiplication\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields the product of \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" and \",mdx(\"em\",{parentName:\"td\"},\"b\"),\".\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" \",\"*\",\"*\",\" \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Power\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" raised to the power of \",mdx(\"em\",{parentName:\"td\"},\"b\"),\".\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" / \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Division\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" divided by \",mdx(\"em\",{parentName:\"td\"},\"b\"),\".\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" % \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Modulo\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields the remainder after dividing \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" by \",mdx(\"em\",{parentName:\"td\"},\"b\"),\".\")))),mdx(\"h5\",e({},{id:\"binary-operators\"}),mdx(\"a\",e({parentName:\"h5\"},{className:\"anchor-link\",href:\"#binary-operators\"}),\"\\xA7\"),\"Binary operators\"),mdx(\"p\",null,\"Operators that operate on the bits of their operands.\"),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Operator\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Name\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Description\"))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" & \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Binary AND\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"TODO\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" \",\"|\",\" \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Binary OR\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"TODO\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" ^ \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Binary XOR\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"TODO\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" << \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Bitwise left shift.\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"TODO\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" >> \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Bitwise right shift.\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"TODO\")))),mdx(\"h5\",e({},{id:\"relational-operators\"}),mdx(\"a\",e({parentName:\"h5\"},{className:\"anchor-link\",href:\"#relational-operators\"}),\"\\xA7\"),\"Relational operators\"),mdx(\"p\",null,\"Relational operators compare their two operands and yield a boolean value depending on the comparison's result.\"),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Operator\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Name\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Description\"))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" == \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Equal to\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields \",mdx(\"inlineCode\",{parentName:\"td\"},\"true\"),\" if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is equal to \",mdx(\"em\",{parentName:\"td\"},\"b\"),\", \",mdx(\"inlineCode\",{parentName:\"td\"},\"false\"),\" otherwise.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" != \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Not equal to\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields \",mdx(\"inlineCode\",{parentName:\"td\"},\"false\"),\" if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is equal to \",mdx(\"em\",{parentName:\"td\"},\"b\"),\", \",mdx(\"inlineCode\",{parentName:\"td\"},\"true\"),\" otherwise.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" < \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Less than\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Requires both operands to be numbers. Yields \",mdx(\"inlineCode\",{parentName:\"td\"},\"true\"),\" if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is less than \",mdx(\"em\",{parentName:\"td\"},\"b\"),\", \",mdx(\"inlineCode\",{parentName:\"td\"},\"false\"),\" otherwise.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" > \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Greater than\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Requires both operands to be numbers. Yields \",mdx(\"inlineCode\",{parentName:\"td\"},\"true\"),\" if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is greater than \",mdx(\"em\",{parentName:\"td\"},\"b\"),\", \",mdx(\"inlineCode\",{parentName:\"td\"},\"false\"),\" otherwise.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" <= \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Less than or equal to\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Requires both operands to be numbers. Yields \",mdx(\"inlineCode\",{parentName:\"td\"},\"true\"),\" if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is less than or equal to \",mdx(\"em\",{parentName:\"td\"},\"b\"),\", \",mdx(\"inlineCode\",{parentName:\"td\"},\"false\"),\" otherwise.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" >= \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Greater than or equal to\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Requires both operands to be numbers. Yields \",mdx(\"inlineCode\",{parentName:\"td\"},\"true\"),\" if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is greater than or equal to \",mdx(\"em\",{parentName:\"td\"},\"b\"),\", \",mdx(\"inlineCode\",{parentName:\"td\"},\"false\"),\" otherwise.\")))),mdx(\"h5\",e({},{id:\"logical-operators\"}),mdx(\"a\",e({parentName:\"h5\"},{className:\"anchor-link\",href:\"#logical-operators\"}),\"\\xA7\"),\"Logical operators\"),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Operator\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Name\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Description\"))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" && \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Logical AND\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" if is not truthful. Otherwise yields \",mdx(\"em\",{parentName:\"td\"},\"b\"),\". Note that \",mdx(\"em\",{parentName:\"td\"},\"b\"),\" is only evaluated if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is truthful.\")),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" \",\"|\",\"|\",\" \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Logical OR\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" if it is truthful. Otherwise yields \",mdx(\"em\",{parentName:\"td\"},\"b\"),\". Note that \",mdx(\"em\",{parentName:\"td\"},\"b\"),\" is only evaluated if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is not truthful.\")))),mdx(Todo,{mdxType:\"Todo\"},\"Should these operation always return a boolean instead of the result yielded by its operands?\"),mdx(\"h5\",e({},{id:\"other-operators\"}),mdx(\"a\",e({parentName:\"h5\"},{className:\"anchor-link\",href:\"#other-operators\"}),\"\\xA7\"),\"Other operators\"),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Operator\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Name\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Description\"))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" ?? \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Null coalescing\"),mdx(\"td\",e({parentName:\"tr\"},{align:null}),\"Yields \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" if it is not null. Otherwise yields \",mdx(\"em\",{parentName:\"td\"},\"b\"),\". Note that \",mdx(\"em\",{parentName:\"td\"},\"b\"),\" is only evaluated if \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" is \",mdx(\"inlineCode\",{parentName:\"td\"},\"null\"),\".\")))),mdx(\"h4\",e({},{id:\"assignment-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#assignment-expressions\"}),\"\\xA7\"),\"Assignment expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"AssignExpr\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"nonterminal\",name:\"AssignOp\"},{type:\"nonterminal\",name:\"Expr\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"AssignOp\",definition:{type:\"choice\",children:[\"=\",\"+=\",\"-=\",\"*=\",\"**=\",\"/=\",\"%=\"]},mdxType:\"Rule\"})),mdx(\"p\",null,\"Assignment expressions evaluate their operands and assign the result to the location specified at the left hand side.\"),mdx(\"p\",null,\"The \",mdx(\"inlineCode\",{parentName:\"p\"},\"=\"),` assignment operator simply evaluates its right hand side and assigns it to the target location.\nThe other `,mdx(\"em\",{parentName:\"p\"},\"compound assignment operators\"),\" take the current value of the left hand side expression into account:\"),mdx(\"table\",null,mdx(\"thead\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"thead\"},mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Compound operator\"),mdx(\"th\",e({parentName:\"tr\"},{align:null}),\"Equivalent Expression\"))),mdx(\"tbody\",{parentName:\"table\"},mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" += \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" = \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" + \",mdx(\"em\",{parentName:\"td\"},\"b\"))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" -= \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" = \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" - \",mdx(\"em\",{parentName:\"td\"},\"b\"))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" \",\"*\",\"= \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" = \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" \",\"*\",\" \",mdx(\"em\",{parentName:\"td\"},\"b\"))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" \",\"*\",\"*\",\"= \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" = \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" \",\"*\",\"*\",\" \",mdx(\"em\",{parentName:\"td\"},\"b\"))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" /= \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" = \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" / \",mdx(\"em\",{parentName:\"td\"},\"b\"))),mdx(\"tr\",{parentName:\"tbody\"},mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" %= \",mdx(\"em\",{parentName:\"td\"},\"b\")),mdx(\"td\",e({parentName:\"tr\"},{align:null}),mdx(\"em\",{parentName:\"td\"},\"a\"),\" = \",mdx(\"em\",{parentName:\"td\"},\"a\"),\" % \",mdx(\"em\",{parentName:\"td\"},\"b\"))))),mdx(\"p\",null,`Not all kinds of expression are valid targets for assignments.\nThe following expressions are valid:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\"Var expressions\"),`.\nThe result is written to the specified variable.`),mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\"(Tuple) field expressions\"),`.\nThe result is written to the specified (tuple) field.`),mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\"Element expressions\"),`.\nThe result is written to the specified element.`),mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\"Tuple expressions\"),` containing expressions of the previously mentioned kind.\nThe result should be a tuple that will be decomposed and assigned to the specified locations.`)),mdx(\"p\",null,\"The left hand side of an assignment expression may not use the optional variants of the \",mdx(\"em\",{parentName:\"p\"},\"field-\"),\", \",mdx(\"em\",{parentName:\"p\"},\"element-\"),\" and \",mdx(\"em\",{parentName:\"p\"},\"call expressions\"),\".\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    var x = 3;\n    x = 4;\n    std.print(\"(1)\", x); // (1) 4\n\n    var y = 3;\n    (x, y) = (y, x);\n    std.print(\"(2)\", x, y); // (2) 3 4\n\n    const z = [1, 2];\n    (z[0], z[1]) = (\"a\", \"b\");\n    std.print(\"(3)\", z[0], z[1]); // (3) a b\n}\n`)),mdx(\"h4\",e({},{id:\"break-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#break-expressions\"}),\"\\xA7\"),\"Break expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"BreakExpr\",definition:\"break\",mdxType:\"Rule\"})),mdx(\"p\",null,\"Aborts execution of the current (most nested) \",mdx(\"em\",{parentName:\"p\"},\"for\"),\", \",mdx(\"em\",{parentName:\"p\"},\"for each\"),\" or \",mdx(\"em\",{parentName:\"p\"},\"while\"),` loop.\nExecution resumes directly after the loop statement.`),mdx(\"p\",null,\"Note that pending \",mdx(\"em\",{parentName:\"p\"},\"defer\"),\" statements will be executed before execution resumes after the loop.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    var i = 0;\n    while (true) {\n        if i == 3 {\n            break;\n        }\n        std.print(i);\n        i += 1;\n    }\n    std.print(\"done\");\n}\n`)),mdx(\"h4\",e({},{id:\"continue-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#continue-expressions\"}),\"\\xA7\"),\"Continue expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"ContinueExpr\",definition:\"continue\",mdxType:\"Rule\"})),mdx(\"p\",null,\"Jumps directly to the end of the current (most nested) \",mdx(\"em\",{parentName:\"p\"},\"for\"),\", \",mdx(\"em\",{parentName:\"p\"},\"for each\"),\" or \",mdx(\"em\",{parentName:\"p\"},\"while\"),\" loop's body.\"),mdx(\"p\",null,\"Note that pending \",mdx(\"em\",{parentName:\"p\"},\"defer\"),\" statements will be executed before execution of the loop resumes.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    for var i = 0; i <= 6; i += 1 {\n        if i % 2 == 0 {\n          continue; // Skip even numbers\n        }\n        std.print(i);\n    }\n}\n`)),mdx(\"h4\",e({},{id:\"return-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#return-expressions\"}),\"\\xA7\"),\"Return expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"ReturnExpr\",definition:[\"return\",{type:\"optional\",child:{type:\"nonterminal\",name:\"Expr\"}}],mdxType:\"Rule\"})),mdx(\"p\",null,`Returns from the current (most nested) function.\nProgram execution will continue in that function's caller.`),mdx(\"p\",null,`An optional expression may be specified.\nThe value yielded by that expression will be come the function's return value.\nIf the expression is omitted, `,mdx(\"inlineCode\",{parentName:\"p\"},\"null\"),\" is returned.\"),mdx(\"p\",null,\"Note that pending \",mdx(\"em\",{parentName:\"p\"},\"defer\"),\" statements will be executed when returning from a function.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    std.print(next_even(1));\n    std.print(next_even(2));\n}\n\nfunc next_even(n) {\n    if n % 2 == 0 {\n        return n;\n    }\n    return n + 1;\n}\n`)),mdx(\"h4\",e({},{id:\"grouped-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#grouped-expressions\"}),\"\\xA7\"),\"Grouped expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"GroupedExpr\",definition:[\"(\",{type:\"nonterminal\",name:\"Expr\"},\")\"],mdxType:\"Rule\"})),mdx(\"p\",null,\"Parentheses can be used to group expressions, for example to override the default precedence rules within expressions:\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\",metastring:\"import std;\",import:!0,\"std;\":!0}),`\nexport func main() {\n    std.print(1 + 2 * 3);\n    std.print((1 + 2) * 3);\n}\n`)),mdx(\"h4\",e({},{id:\"if-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#if-expressions\"}),\"\\xA7\"),\"If expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"IfExpr\",definition:[\"if\",{type:\"note\",child:{type:\"nonterminal\",name:\"Expr\"},note:\"Excluding BlockExpr\"},{type:\"nonterminal\",name:\"BlockExpr\"},{type:\"optional\",child:[\"else\",{type:\"choice\",children:[{type:\"nonterminal\",name:\"IfExpr\"},{type:\"nonterminal\",name:\"BlockExpr\"}]}]}],mdxType:\"Rule\"})),mdx(\"p\",null,`If expressions provide support for conditional execution.\nThey consist of a mandatory condition, a `,mdx(\"em\",{parentName:\"p\"},\"then\"),\" block expression, an optional series of \",mdx(\"em\",{parentName:\"p\"},\"else if\"),\" expressions with additional conditions and finally an optional \",mdx(\"em\",{parentName:\"p\"},\"else\"),\" block.\"),mdx(\"p\",null,\"If the condition yields a truthful value, the \",mdx(\"em\",{parentName:\"p\"},\"then\"),` block is executed and all other blocks are skipped.\nOtherwise, conditions of any `,mdx(\"em\",{parentName:\"p\"},\"else if\"),` expressions are attempted in order, and the block expression after the first truthful condition will be executed.\nIf no condition yielded a truthful value, the optional `,mdx(\"em\",{parentName:\"p\"},\"else\"),\" block is executed instead.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    if_example(3);\n    if_example(5);\n    if_example(10);\n}\n\nfunc if_example(x) {\n    if x == 3 {\n        std.print(\"x is 3\");\n    } else if x % 2 == 1 {\n        std.print(\"x is odd\");\n    } else {\n        std.print(\"x is something else\");\n    }\n}\n\n`)),mdx(\"p\",null,`If expressions may be used in positions where a value is expected.\nIf that is the case, then the expression `,mdx(\"em\",{parentName:\"p\"},\"must\"),\" have an \",mdx(\"em\",{parentName:\"p\"},\"else\"),\" block and all blocks must yield a value as well.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const u = 3;\n    const v = if u > 0 {\n        u + 1;\n    } else {\n        u - 1;\n    };\n    std.print(v);\n}\n`)),mdx(Todo,{mdxType:\"Todo\"},\"Open design question: should a shorthand syntax (no block statement) be allowed? For example `const foo = if condition 1 else 2;`\"),mdx(\"h4\",e({},{id:\"function-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#function-expressions\"}),\"\\xA7\"),\"Function expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"FuncExpr\",definition:{type:\"nonterminal\",name:\"FuncDecl\"},mdxType:\"Rule\"})),mdx(\"p\",null,\"Function expressions yield the declared function as a value.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const twice = func(x) = x * 2;\n    std.print(twice(1));\n}\n`)),mdx(\"h4\",e({},{id:\"block-expressions\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#block-expressions\"}),\"\\xA7\"),\"Block expressions\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"BlockExpr\",definition:[\"{\",{type:\"repeat\",child:{type:\"nonterminal\",name:\"Stmt\"}},\"}\"],mdxType:\"Rule\"})),mdx(\"p\",null,`Block expressions contain a sequence of statements.\nWhen a block expression is evaluated, all its statements are evaluated in order.`),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    // this function body is a block expression in its own right\n    std.print(\"a\");\n    std.print(\"b\");\n\n    // blocks can be nested using if expressions, loops etc. or plainly like this:\n    {\n        std.print(\"c\");\n        std.print(\"d\");\n    }\n}\n`)),mdx(\"p\",null,`Block expressions may be used in positions where a value is expected.\nIf that is the case, there must be at least one statement and the last statement must yield a value.\nThat value will then be yielded by the block expression.`),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    // This pattern is helpful for constants with complex initialization logic\n    const value = {\n        var v = 1;\n        if true {\n            v += 1;\n        }\n        if !false {\n            v *= 2;\n        }\n        v;\n    };\n    std.print(value);\n}\n`)),mdx(\"h3\",e({},{id:\"literals\"}),mdx(\"a\",e({parentName:\"h3\"},{className:\"anchor-link\",href:\"#literals\"}),\"\\xA7\"),\"Literals\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"Literal\",definition:{type:\"choice\",children:[\"true\",\"false\",\"null\",{type:\"nonterminal\",name:\"Integer\"},{type:\"nonterminal\",name:\"Float\"},{type:\"nonterminal\",name:\"String\"},{type:\"nonterminal\",name:\"Symbol\"},{type:\"nonterminal\",name:\"TupleLiteral\"},{type:\"nonterminal\",name:\"RecordLiteral\"},{type:\"nonterminal\",name:\"ArrayLiteral\"},{type:\"nonterminal\",name:\"MapLiteral\"},{type:\"nonterminal\",name:\"SetLiteral\"}]},mdxType:\"Rule\"})),mdx(\"p\",null,`Literals are expressions are source code representations of concrete values.\nLiterals themselves do not require and additional context to evaluate (although nested expressions might).`),mdx(\"h4\",e({},{id:\"tuple-literals\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#tuple-literals\"}),\"\\xA7\"),\"Tuple literals\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"TupleLiteral\",definition:[\"(\",{type:\"optional\",child:{type:\"nonterminal\",name:\"TupleElements\"}},\")\"],mdxType:\"Rule\"}),mdx(Rule,{name:\"TupleElements\",definition:[{type:\"repeat\",min:1,child:[{type:\"nonterminal\",name:\"Expr\"},\",\"]},{type:\"optional\",child:{type:\"nonterminal\",name:\"Expr\"}}],mdxType:\"Rule\"})),mdx(\"p\",null,\"Creates a tuple containing the values yielded by the nested expressions in their written order.\"),mdx(\"p\",null,\"In order to avoid ambiguity with \",mdx(\"em\",{parentName:\"p\"},\"grouped expressions\"),\", a one-element tuple must be contain a trailing comma.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const t0 = (); // empty tuple\n    std.print(std.debug_repr(t0));\n\n    const t1 = (1, ); // one element\n    std.print(std.debug_repr(t1));\n\n    const t2 = (1, 2); // two elements\n    std.print(std.debug_repr(t2));\n}\n`)),mdx(\"h4\",e({},{id:\"record-literals\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#record-literals\"}),\"\\xA7\"),\"Record literals\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"RecordLiteral\",definition:[\"(\",{type:\"choice\",children:[{type:\"nonterminal\",name:\"RecordElements\"},\":\"]},\")\"],mdxType:\"Rule\"}),mdx(Rule,{name:\"RecordElements\",definition:[{type:\"nonterminal\",name:\"RecordEntry\"},{type:\"repeat\",child:[\",\",{type:\"nonterminal\",name:\"RecordEntry\"}]},{type:\"optional\",child:\",\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"RecordEntry\",definition:[{type:\"nonterminal\",name:\"Identifier\"},\":\",{type:\"nonterminal\",name:\"Expr\"}],mdxType:\"Rule\"})),mdx(\"p\",null,\"Creates a record containing the values yielded by the nested expressions associated with the declared field names.\"),mdx(\"p\",null,\"In order to avoid ambiguity with empty tuples, an empty record must be spelled \",mdx(\"inlineCode\",{parentName:\"p\"},\"(:)\"),\".\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const r0 = (:);\n    std.print(std.debug_repr(r0));\n\n    const r1 = (field: \"value\");\n    std.print(std.debug_repr(r1));\n\n    const r2 = (\n        x: 3.14,\n        y: std.PI\n    );\n    std.print(std.debug_repr(r2));\n}\n`)),mdx(\"h4\",e({},{id:\"array-literals\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#array-literals\"}),\"\\xA7\"),\"Array literals\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"ArrayLiteral\",definition:[\"[\",{type:\"optional\",child:{type:\"nonterminal\",name:\"ArrayElements\"}},\"]\"],mdxType:\"Rule\"}),mdx(Rule,{name:\"ArrayElements\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"repeat\",child:[\",\",{type:\"nonterminal\",name:\"Expr\"}]},{type:\"optional\",child:\",\"}],mdxType:\"Rule\"})),mdx(\"p\",null,\"Creates an array containing the values yielded by the nested expressions in their written order.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const a0 = [];\n    std.print(std.debug_repr(a0));\n\n    const a1 = [1, 2, 3];\n    std.print(std.debug_repr(a1));\n\n    a1.append(4);\n    std.print(std.debug_repr(a1));\n}\n`)),mdx(\"h4\",e({},{id:\"map-literals\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#map-literals\"}),\"\\xA7\"),\"Map literals\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"MapLiteral\",definition:[\"map\",\"{\",{type:\"optional\",child:{type:\"nonterminal\",name:\"MapElements\"}},\"}\"],mdxType:\"Rule\"}),mdx(Rule,{name:\"MapElements\",definition:[{type:\"nonterminal\",name:\"MapElement\"},{type:\"repeat\",child:[\",\",{type:\"nonterminal\",name:\"MapElement\"}]},{type:\"optional\",child:\",\"}],mdxType:\"Rule\"}),mdx(Rule,{name:\"MapElement\",definition:[{type:\"nonterminal\",name:\"Expr\"},\":\",{type:\"nonterminal\",name:\"Expr\"}],mdxType:\"Rule\"})),mdx(\"p\",null,`Creates a map with the specified elements.\nEvery element is specified using two expressions.\nThe expression to the right of the `,mdx(\"inlineCode\",{parentName:\"p\"},\":\"),\" specifies the \",mdx(\"em\",{parentName:\"p\"},\"value\"),\", and the left expression specifies the associated \",mdx(\"em\",{parentName:\"p\"},\"key\"),\".\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const pi = 3.14;\n    const m = map{\n        1: 2,\n        \"a\": null,\n        \"pi\": pi,\n        #foo: \"bar\",\n    };\n\n    std.print(std.debug_repr(m));\n}\n`)),mdx(\"h4\",e({},{id:\"set-literals\"}),mdx(\"a\",e({parentName:\"h4\"},{className:\"anchor-link\",href:\"#set-literals\"}),\"\\xA7\"),\"Set literals\"),mdx(Rules,{mdxType:\"Rules\"},mdx(Rule,{name:\"SetLiteral\",definition:[\"set\",\"{\",{type:\"optional\",child:{type:\"nonterminal\",name:\"SetElements\"}},\"}\"],mdxType:\"Rule\"}),mdx(Rule,{name:\"SetElements\",definition:[{type:\"nonterminal\",name:\"Expr\"},{type:\"repeat\",child:[\",\",{type:\"nonterminal\",name:\"Expr\"}]},{type:\"optional\",child:\",\"}],mdxType:\"Rule\"})),mdx(\"p\",null,\"Creates a set with the specified elements.\"),mdx(\"span\",{className:\"caption\"},\"Example:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-tiro\"}),`import std;\n\nexport func main() {\n    const pi = 3.14;\n    const s = set{\n        2,\n        null,\n        pi,\n        \"bar\",\n    };\n\n    std.print(std.debug_repr(s));\n}\n`)),mdx(\"h2\",e({},{id:\"modules\"}),mdx(\"a\",e({parentName:\"h2\"},{className:\"anchor-link\",href:\"#modules\"}),\"\\xA7\"),\"Modules\"),mdx(Todo,{mdxType:\"Todo\"},\"Documentation\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}},"__N_SSG":true}