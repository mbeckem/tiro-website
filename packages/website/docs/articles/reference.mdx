---
title: "Reference Documentation"
slug: "/reference"
---

# Tiro Reference Documentation

## Basics

Tiro accepts UTF-8 encoded source files as input.
Source files must conform to the rules outlined in this document to form a valid program.
At the very basic level, a source file will be recognized as a series of tokens.

<Info title="Note">

Grammar rules in this section work on _characters_.
No whitespace is not allowed unless it matches one of the required patterns.

</Info>

### Whitespace

Whitespace tokens consists of a sequence of characters having the Unicode _White_Space_ property. (TODO: White Space Pattern instead, add link)
Whitespace is not significant: its only use is to separate characters of adjacent tokens that would otherwise be parsed as a single token.

### Comments

Comments are used to annotate source code, but they have no meaning of their own.
They are simply treated as whitespace.

<Rules>

<Rule
  name="Comment"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "LineComment" },
      { type: "nonterminal", name: "BlockComment" }
    ]
  }}
/>

<Rule
  name="LineComment"
  definition={[
    "//",
    {
      type: "repeat",
      child: [
        {
          type: "not",
          child: "\\n"
        }
      ]
    }
  ]}
/>

<Rule
  name="BlockComment"
  definition={[
    "/*",
    {
      type: "repeat",
      child: {
        type: "choice",
        children: [
          { type: "nonterminal", name: "BlockComment" },
          { type: "repeat", child: { type: "not", child: "*/" } }
        ]
      }
    },
    "*/"
  ]}
/>

</Rules>

Line comments are introduced by `//` and continue until the end of the line.
Block comments are delimited by `/*` and `*/` and may be nested.

### Keywords

The following words have special meaning in the Tiro programming language:

<ItemTable
  columns={5}
  items={[
    "assert",
    "break",
    "const",
    "continue",
    "defer",
    "else",
    "export",
    "false",
    "for",
    "func",
    "if",
    "import",
    "in",
    "null",
    "return",
    "true",
    "var",
    "while"
  ]}
/>

#### Reserved keywords

The following keywords are reserved for future use:

<ItemTable
  columns={5}
  items={[
    "as",
    "catch",
    "class",
    "interface",
    "is",
    "package",
    "protocol",
    "scope",
    "struct",
    "switch",
    "throw",
    "try",
    "yield"
  ]}
/>

### Identifiers

Identifiers are used to name items.
They consist of one or more identifier characters as defined by the _XID_Start_ and _XID_Continue_ Unicode properties. (TODO: Link)
Keywords cannot be used as identifiers.

<Rules>

<Rule
  name="Identifier"
  definition={{
    type: "note",
    child: {
      type: "nonterminal",
      name: "KeywordOrIdentifier"
    },
    note: "Not including keywords"
  }}
/>

<Rule
  name="KeywordOrIdentifier"
  definition={[
    { type: "choice", children: [{ type: "nonterminal", name: "XID_Start", undefined: true }, "_"] },
    {
      type: "repeat",
      child: {
        type: "nonterminal",
        name: "XID_Continue",
        undefined: true
      }
    }
  ]}
/>

</Rules>

### Number literals

<Rules>

<Rule
  name="Integer"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "DecInteger" },
      { type: "nonterminal", name: "BinInteger" },
      { type: "nonterminal", name: "OctInteger" },
      { type: "nonterminal", name: "HexInteger" }
    ]
  }}
/>

<Rule
  name="DecInteger"
  definition={[
    { type: "nonterminal", name: "DecDigit" },
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "DecDigit" }, "_"] }
    }
  ]}
/>

<Rule
  name="BinInteger"
  definition={[
    "0b",
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "BinDigit" }, "_"] }
    },
    { type: "nonterminal", name: "BinDigit" },
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "BinDigit" }, "_"] }
    }
  ]}
/>

<Rule
  name="OctInteger"
  definition={[
    "0o",
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "OctDigit" }, "_"] }
    },
    { type: "nonterminal", name: "OctDigit" },
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "OctDigit" }, "_"] }
    }
  ]}
/>

<Rule
  name="HexInteger"
  definition={[
    "0x",
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "HexDigit" }, "_"] }
    },
    { type: "nonterminal", name: "HexDigit" },
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "HexDigit" }, "_"] }
    }
  ]}
/>

<Rule
  name="DecDigit"
  definition={{
    type: "range",
    value: ["0", "9"]
  }}
/>

<Rule
  name="BinDigit"
  definition={{
    type: "choice",
    children: ["0", "1"]
  }}
/>

<Rule
  name="OctDigit"
  definition={{
    type: "range",
    value: ["0", "7"]
  }}
/>

<Rule
  name="HexDigit"
  definition={{
    type: "choice",
    children: [
      { type: "range", value: ["0", "9"] },
      { type: "range", value: ["a", "f"] },
      { type: "range", value: ["A", "F"] }
    ]
  }}
/>

</Rules>

<Todo>
  
Document floating point numbers.

</Todo>

### String literals

Strings are sequences of characters enclosed by matching quote characters (`"` or `'`).
Within a string, variables can be interpolated when prefixed with a `$` sign and full expressions can be interpolated when enclosed within a
block started with `${` and closed with a `}` sign.

<Rules>

<Rule
  name="String"
  definition={[
    {
      type: "nonterminal",
      name: "StringDelimiter"
    },
    {
      type: "repeat",
      child: {
        type: "choice",
        children: [
          { type: "nonterminal", name: "PlainStringContent" },
          { type: "nonterminal", name: "EscapeSequence" },
          { type: "nonterminal", name: "InterpolatedValue" }
        ]
      }
    },
    {
      type: "note",
      child: {
        type: "nonterminal",
        name: "StringDelimiter"
      },
      note: "matches starting delimiter"
    }
  ]}
/>

<Rule name="StringDelimiter" definition={{ type: "choice", children: ['"', "'"] }} />

<Rule
  name="PlainStringContent"
  definition={{
    type: "repeat",
    child: {
      type: "not",
      child: {
        type: "choice",
        children: [
          "\\",
          "$",
          {
            type: "note",
            child: {
              type: "nonterminal",
              name: "StringDelimiter"
            },
            note: "matches starting delimiter"
          }
        ]
      }
    }
  }}
/>

<Rule
  name="InterpolatedValue"
  definition={{
    type: "choice",
    children: [
      ["$", { type: "nonterminal", name: "VarExpr" }],
      ["${", { type: "nonterminal", name: "Expr" }, "}"]
    ]
  }}
/>

</Rules>

<Todo>

Open design questions:

- Should strings be multi line by default (current state)? Or should a `\` at the end of a line be necessary to continue to the following line?
- Should all strings support interpolation by default? Or provide a variant (e.g. delimited by `'`) that does _not_ support interpolation?
- Should all strings be guaranteed (required) to be valid UTF-8?

</Todo>

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    const greeting = "Hello";
    std.print("$greeting ${get_target()}!");
}

func get_target() {
    return "World";
}
```

#### Escape sequences

<Rules>

<Rule
  name="EscapeSequence"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "EscapedCharacter" },
      { type: "nonterminal", name: "AsciiEscape" },
      { type: "nonterminal", name: "UnicodeEscape" }
    ]
  }}
/>

<Rule
  name="EscapedCharacter"
  definition={{ type: "choice", children: ["\\\\", "\\n", "\\r", "\\t", '\\"', "\\'", "\\$"] }}
/>

<Rule
  name="AsciiEscape"
  definition={["\\x", { type: "nonterminal", name: "HexDigit" }, { type: "nonterminal", name: "HexDigit" }]}
/>

<Rule
  name="UnicodeEscape"
  definition={[
    "\\u{",
    {
      type: "repeat",
      min: 1,
      child: {
        type: "nonterminal",
        name: "HexDigit"
      }
    },
    "}"
  ]}
/>

</Rules>

Escape sequences produce the following string content:

| Escape Sequence    | Production                  |
| ------------------ | --------------------------- | ------------------------------------------------------------------------------------------ |
| `\\`               | Literal `\`                 |                                                                                            |
| `\n`               | Newline                     |                                                                                            |
| `\r`               | Carriage return             |                                                                                            |
| `\t`               | Tabulator                   |                                                                                            |
| `\"`               | Literal `"`                 |                                                                                            |
| `\'`               | Literal `'`                 |                                                                                            |
| `\$`               | Literal `$`                 |                                                                                            |
| `\x` digits..      | A single byte               | The numeric value of the two hex digits is produced as a byte (TODO: Must be valid utf-8?) |
| `\u{` digits.. `}` | A single unicode code point | The sequence of hex digits is interpreted as the value of a unicode code point.            |

### Symbol literals

<Rules>

<Rule name="Symbol" definition={["#", { type: "nonterminal", name: "Identifier" }]} />

</Rules>

<Todo>

Documentation

</Todo>

## Grammar

<Info title="Note">

Grammar rules in this section work on _tokens_.
Any amount of white space may appear between matching tokens.

</Info>

### Items

<Rules>

<Rule
  name="File"
  definition={{
    type: "repeat",
    child: {
      type: "nonterminal",
      name: "Item"
    }
  }}
/>

<Rule
  name="Item"
  definition={[
    {
      type: "optional",
      child: "export"
    },
    {
      type: "choice",
      children: [
        [{ type: "nonterminal", name: "ImportDecl" }, ";"],
        [{ type: "nonterminal", name: "VarDecl" }, ";"],
        [{ type: "nonterminal", name: "FuncDecl" }]
      ]
    }
  ]}
/>

</Rules>

A Tiro source file is a sequence of _Items_.
An item containing the `export` modifier will be exported from the current module.
Exported items are visible to other modules and may be imported.

#### Imports

<Rules>

<Rule
  name="ImportDecl"
  definition={[
    "import",
    {
      type: "nonterminal",
      name: "ImportPath"
    },
    {
      type: "optional",
      child: ["as", { type: "nonterminal", name: "Identifier" }]
    }
  ]}
/>

<Rule
  name="ImportPath"
  definition={[
    { type: "nonterminal", name: "Identifier" },
    {
      type: "repeat",
      child: [".", { type: "nonterminal", name: "Identifier" }]
    }
  ]}
/>

</Rules>

An `import` item imports the module referenced by the _ImportPath_ and introduces it into the current scope.
The last _Identifier_ in the _ImportPath_ serves as the name of the imported reference by default.
A custom name may be provided by using the `as` keyword.

<Todo>

The import path must currently point to a module.
It should also allow for entities within a module.

For example, `import std.print as myprint` should be valid.

Grouping imports should be possible, for example `import std { print, PI as MY_PI}`.

</Todo>

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    std.print("Hello World");
}
```

#### Variables

<Rules>

<Rule
  name="VarDecl"
  definition={[
    { type: "choice", children: ["const", "var"] },
    { type: "nonterminal", name: "Binding" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Binding" }] }
  ]}
/>

<Rule
  name="Binding"
  definition={[
    { type: "nonterminal", name: "BindingPattern" },
    { type: "optional", child: ["=", { type: "nonterminal", name: "Expr" }] }
  ]}
/>

<Rule
  name="BindingPattern"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "Identifier" },
      { type: "nonterminal", name: "TupleBindingPattern" }
    ]
  }}
/>

<Rule
  name="TupleBindingPattern"
  definition={[
    "(",
    { type: "nonterminal", name: "Identifier" },
    {
      type: "repeat",
      child: [",", { type: "nonterminal", name: "Identifier" }]
    },
    ")"
  ]}
/>

</Rules>

Variable declarations introduce one or more variables into the current scope.
A variable declaration contains _Bindings_, which may provide an initializer expression for the _Identifier_ or _Identifiers_ mentioned in the _BindingPattern_.

Bindings introduce a single new variable when the _BindingPattern_ consists of a single identifier.
The optional initializer expression may yield any value in this case.

A _TupleBindingPattern_ introduces multiple variables at once.
The optional initializer for a tuple pattern must yield a tuple value with a compatible size (at least the number of declared variable names).

Using the `var` keyword creates a mutable variable, while a variable declared using the `const` keyword cannot be reassigned after its initialization.
Constants must have an initializer.

| Declaration kind     | Example                | Meaning                                                              |
| -------------------- | ---------------------- | -------------------------------------------------------------------- |
| Simple declaration   | `var x;`               | Declares the initialized variable _x_ in the current scope           |
| Multiple variables   | `var x, y;`            | Declares _x_ and _y_ in the current scope                            |
| With initializer     | `var x = 3.14;`        | Declares _x_ and with the initial value `3.14`                       |
| Constant declaration | `const x = 3.14; `     | Like the above, but _x_ cannot be reassigned anymore                 |
| Tuple unpacking      | `var (x, y) = (1, 2);` | Unpacks the right hand side tuple into the new variables _x_ and _y_ |

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    var a = "single variable";
    const b = 1, c = 2;
    var (d, e) = ("first", "second");
    std.print(a, b, c, d, e);
}
```

#### Functions

<Rules>

<Rule
  name="FuncDecl"
  definition={[
    "func",
    { type: "optional", child: { type: "nonterminal", name: "Identifier" } },
    "(",
    { type: "optional", child: { type: "nonterminal", name: "ParamList" } },
    ")",
    { type: "nonterminal", name: "FuncBody" }
  ]}
/>

<Rule
  name="ParamList"
  definition={[
    { type: "nonterminal", name: "Identifier" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Identifier" }] }
  ]}
/>

<Rule
  name="FuncBody"
  definition={{
    type: "choice",
    children: [["=", { type: "nonterminal", name: "Expr" }], { type: "nonterminal", name: "BlockExpr" }]
  }}
/>

</Rules>

A function declaration creates a new function.
Functions may have a name, a set of parameters and a body.
When a function is _invoked_, values passed as arguments in the function call expression will be bound to the declared parameters of that function.

The body of a function may be specified as either a _BlockExpr_ or as a single expression introduced by a `=` sign.
The shorthand syntax is useful for very simple functions.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    std.print(block_body(1));
    std.print(shorthand_body(2));
}

func block_body(p) {
    const result = p * 2;
    return result;
}

func shorthand_body(p) = p * 2;
```

### Statements

<Rules>

<Rule
  name="Stmt"
  definition={{
    type: "choice",
    children: [
      [{ type: "nonterminal", name: "VarDecl" }, ";"],
      [{ type: "nonterminal", name: "AssertStmt" }, ";"],
      [{ type: "nonterminal", name: "DeferStmt" }, ";"],
      [{ type: "nonterminal", name: "WhileStmt" }],
      [{ type: "nonterminal", name: "ForEachStmt" }],
      [{ type: "nonterminal", name: "ForStmt" }],
      [{ type: "nonterminal", name: "IfExpr" }],
      [{ type: "nonterminal", name: "BlockExpr" }],
      [{ type: "nonterminal", name: "Expr" }, ";"],
      ";"
    ]
  }}
/>

</Rules>

Statements are constructs used in block expressions such as function bodies.
Most statements must be terminated by a semicolon.
The semicolon is optional for block-like statements, where the end of the statement is obvious from the position of the closing `}`.

#### Assertions

<Rules>

<Rule
  name="AssertStmt"
  definition={[
    "assert",
    "(",
    { type: "nonterminal", name: "Expr" },
    { type: "optional", child: [",", { type: "nonterminal", name: "String" }] },
    ")"
  ]}
/>

</Rules>

An assertion verifies that the expression yields a truthful value.
A failed assertion results in a _panic_.

An optional message argument may be specified; it will be included in the panic's diagnostic error message.

<Info>

Assertions should be used to verify program invariants during development.
They may be disabled by compilation flags.
Do not rely on their presence at runtime.
Most importantly, avoid side effects inside assertions.

</Info>

<span className="caption">Example:</span>

```tiro
export func main() {
    var n = 1;
    assert(n % 2 == 0, "n must be even!"); // fails
}
```

#### While loops

#### Defer statements

<Rules>

<Rule name="DeferStmt" definition={["defer", { type: "nonterminal", name: "Expr" }]} />

</Rules>

The defer statement registers an expression to be evaluated when the program leaves the current scope.
It's main use is to ensure that resources are cleaned up properly.

Defer statements that have been visited by the program will run even if the scope is being left abruptly, such as by an early `return`, `break`, `continue` or a panic.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    std.print("acquire resource");
    defer std.print("release resource");
    std.print("use resource");
}
```

#### While loops

<Rules>

<Rule
  name="WhileStmt"
  definition={["while", { type: "nonterminal", name: "Expr" }, { type: "nonterminal", name: "BlockExpr" }]}
/>

A while loop consists of a condition expression and a loop body.
The condition will be repeatedly evaluated, and while it is truthful, the loop body will also be executed.
The loop's execution stops as soon as the condition is false.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    var i = 0;
    while i < 3 {
        std.print(i);
        i += 1;
    }
    std.print("done");
}
```

</Rules>

#### For-each loops

<Rules>

<Rule
  name="ForEachStmt"
  definition={[
    "for",
    { type: "nonterminal", name: "BindingPattern" },
    "in",
    { type: "nonterminal", name: "Expr" },
    { type: "nonterminal", name: "BlockExpr" }
  ]}
/>

</Rules>

The for-each loop allows iteration over a collection or sequence such as an array.
It requires a _BindingPattern_ that specifies the variable names used for iteration and an expression that yields an iterable sequence.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    const numbers = [1, 2, 3];
    for c in numbers {
        std.print(c);
    }

    const constants = map{
        "pi": 3.14,
        "e": 2.72
    };
    for (name, value) in constants {
        std.print("$name = $value");
    }
}
```

#### Classic for loops

<Rules>

<Rule
  name="ForStmt"
  definition={[
    "for",
    { type: "optional", child: { type: "nonterminal", name: "VarDecl" } },
    ";",
    { type: "optional", child: { type: "nonterminal", name: "Expr" } },
    ";",
    { type: "optional", child: { type: "nonterminal", name: "Expr" } },
    { type: "nonterminal", name: "BlockExpr" }
  ]}
/>

</Rules>

The classic for loop allows iteration using one or more control variables, a condition expression and an update step.

When the loop starts its execution, the optional control variables are defined and possibly initialized.

Before every iteration, the optional condition expression is evaluated, and if it is truthful, the loop body is executed.
If the condition is false, loop execution stops.
If the condition is not defined, it is implicitly truthful.

The optional update expression is evaluated after every completed loop iteration.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    for var i = 0; i < 3; i += 1 {
        std.print(i);
    }
}
```

### Expressions

<Rules>

<Rule
  name="Expr"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "VarExpr" },
      { type: "nonterminal", name: "FieldExpr" },
      { type: "nonterminal", name: "TupleFieldExpr" },
      { type: "nonterminal", name: "IndexExpr" },
      { type: "nonterminal", name: "CallExpr" },
      { type: "nonterminal", name: "UnaryExpr" },
      { type: "nonterminal", name: "BinaryExpr" },
      { type: "nonterminal", name: "AssignExpr" },
      { type: "nonterminal", name: "ContinueExpr" },
      { type: "nonterminal", name: "BreakExpr" },
      { type: "nonterminal", name: "ReturnExpr" },
      { type: "nonterminal", name: "GroupedExpr" },
      { type: "nonterminal", name: "IfExpr" },
      { type: "nonterminal", name: "FuncExpr" },
      { type: "nonterminal", name: "BlockExpr" }
    ]
  }}
/>

</Rules>

Expressions are syntax constructs that yield a value.
Tiro is an expression-oriented language; most syntax constructions are expressions.

<Todo>

Open design question: should loops be expressions?

</Todo>

#### Evaluation order

All expressions are evaluated strictly from left to right.

#### Variable expressions

<Rules>

<Rule
  name="VarExpr"
  definition={{
    type: "nonterminal",
    name: "Identifier"
  }}
/>

</Rules>

A variable expression yields the current value of the variable identified by the given identifier.
Tiro is a lexically scoped language: variables may only be referenced from within the scope in which they have been defined.
If there are multiple variable declarations for the same identifier in scope, the closest variable declaration is referenced.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    const x = 0;
    {
        const x = 1;
        {
            const x = 2;
            std.print(x);
        }
        std.print(x);
    }
    std.print(x);
}
```

#### Field expressions

<Rules>

<Rule
  name="FieldExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "choice", children: [".", "?."] },
    { type: "nonterminal", name: "Identifier" }
  ]}
/>

<Rule
  name="TupleFieldExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "choice", children: [".", "?."] },
    { type: "nonterminal", name: "NonNegativeInt" }
  ]}
/>

</Rules>

A field expression evaluates the expression left to the `.` symbol and yields the specified field of that value.

The `?.` token can be used to make the field lookup optional.
If the left hand side is `null`, the field expression will also yield `null`.

The tuple field expression is a variant of the above that allows to lookup a tuple member instead.
The left hand side expression must yield a tuple value and the right hand side token must be a non negative integer.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    const rec = (x: 1);
    const no_rec = null;
    std.print(rec.x);
    std.print(rec?.x);
    std.print(no_rec?.x);

    const tuple = (1, 2);
    const no_tuple = null;
    std.print(tuple.1);
    std.print(tuple?.1);
    std.print(no_tuple?.1);
}
```

#### Index expressions

<Rules>

<Rule
  name="IndexExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "choice", children: ["[", "?["] },
    { type: "nonterminal", name: "Expr" },
    "]"
  ]}
/>

</Rules>

Index expressions are used to lookup a value within a container by its index.

The `?[` token can be used to make the value lookup optional.
If the left hand side is `null`, the index expression will also yield `null` and the expression between brackets will not be evaluated.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    const numbers = [1, 2, 3];
    std.print(numbers[1]);

    const constants = map{
        "pi": 3.14,
        "e": 2.72
    };
    std.print(constants["pi"]);

    const no_container = null;
    std.print(no_container?[1]);
}
```

#### Call expressions

<Rules>

<Rule
  name="CallExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "choice", children: ["(", "?("] },
    { type: "optional", child: { type: "nonterminal", name: "CallArguments" } },
    ")"
  ]}
/>

<Rule
  name="CallArguments"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Expr" }] }
  ]}
/>

</Rules>

A Call expression invokes a function with a set of arguments.

The first expression must yield a function.
Expressions passed as arguments (between parentheses) will be evaluated, then control will be passed to function with all
arguments bound to the corresponding function parameter.
The call expression yields the return value of the invoked function.

The `?(` token can be used to make the function call optional.
If the function value yields `null`, the arguments will not be evaluated and the entire expression will also yield `null`.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    std.print(add(1, 2));
    std.print(add(4, 2 * 3));
}

func add(x, y) {
    return x + y;
}
```

#### Unary expressions

<Rules>

<Rule
  name="UnaryExpr"
  definition={[
    { type: "nonterminal", name: "UnaryOp" },
    { type: "nonterminal", name: "Expr" }
  ]}
/>

<Rule name="UnaryOp" definition={{ type: "choice", children: ["+", "-", "!", "~"] }} />

</Rules>

Unary expressions evaluate the right hand side expression and then apply the specified operator to its result.

| Operator | Description                                                                                                |
| -------- | ---------------------------------------------------------------------------------------------------------- |
| +        | Unary plus. Requires a number operand. Yields the number as-is.                                            |
| -        | Unary minus. Requires a number operand. Yields the arithmetic negative of its operand.                     |
| !        | Unary NOT. Returns the logical negative of its operand: `false` for all truthful values, `true` otherwise. |
| ~        | Bitwise NOT. Requires an integer operand. Yields an integer with all bits inverted.                        |

#### Binary expressions

<Rules>

<Rule
  name="BinaryExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "nonterminal", name: "BinaryOp" },
    { type: "nonterminal", name: "Expr" }
  ]}
/>

<Rule
  name="BinaryOp"
  definition={{
    type: "choice",
    children: [
      "+",
      "-",
      "*",
      "**",
      "/",
      "%",
      "&",
      "|",
      "<<",
      ">>",
      "^",
      "==",
      "!=",
      "<",
      ">",
      "<=",
      ">=",
      "&&",
      "||",
      "??"
    ]
  }}
/>

</Rules>

Binary expressions apply an operation to the left hand and right hand side expressions..

##### Arithmetic operators

These operators require two numeric operands and apply the specified arithmetic operation on them.

| Operator     | Name           | Description                                     |
| ------------ | -------------- | ----------------------------------------------- |
| _a_ + _b_    | Addition       | Yields the sum of _a_ and _b_.                  |
| _a_ - _b_    | Subtraction    | Yields the difference of _a_ and _b_.           |
| _a_ \* _b_   | Multiplication | Yields the product of _a_ and _b_.              |
| _a_ \*\* _b_ | Power          | Yields _a_ raised to the power of _b_.          |
| _a_ / _b_    | Division       | Yields _a_ divided by _b_.                      |
| _a_ % _b_    | Modulo         | Yields the remainder after dividing _a_ by _b_. |

##### Binary operators

Operators that operate on the bits of their operands.

| Operator   | Name                 | Description |
| ---------- | -------------------- | ----------- |
| _a_ & _b_  | Binary AND           | TODO        |
| _a_ \| _b_ | Binary OR            | TODO        |
| _a_ ^ _b_  | Binary XOR           | TODO        |
| _a_ << _b_ | Bitwise left shift.  | TODO        |
| _a_ >> _b_ | Bitwise right shift. | TODO        |

##### Relational operators

Relational operators compare their two operands and yield a boolean value depending on the comparison's result.

| Operator   | Name                     | Description                                                                                                    |
| ---------- | ------------------------ | -------------------------------------------------------------------------------------------------------------- |
| _a_ == _b_ | Equal to                 | Yields `true` if _a_ is equal to _b_, `false` otherwise.                                                       |
| _a_ != _b_ | Not equal to             | Yields `false` if _a_ is equal to _b_, `true` otherwise.                                                       |
| _a_ < _b_  | Less than                | Requires both operands to be numbers. Yields `true` if _a_ is less than _b_, `false` otherwise.                |
| _a_ > _b_  | Greater than             | Requires both operands to be numbers. Yields `true` if _a_ is greater than _b_, `false` otherwise.             |
| _a_ <= _b_ | Less than or equal to    | Requires both operands to be numbers. Yields `true` if _a_ is less than or equal to _b_, `false` otherwise.    |
| _a_ >= _b_ | Greater than or equal to | Requires both operands to be numbers. Yields `true` if _a_ is greater than or equal to _b_, `false` otherwise. |

##### Logical operators

| Operator     | Name        | Description                                                                                                 |
| ------------ | ----------- | ----------------------------------------------------------------------------------------------------------- |
| _a_ && _b_   | Logical AND | Yields _a_ if is not truthful. Otherwise yields _b_. Note that _b_ is only evaluated if _a_ is truthful.    |
| _a_ \|\| _b_ | Logical OR  | Yields _a_ if it is truthful. Otherwise yields _b_. Note that _b_ is only evaluated if _a_ is not truthful. |

<Todo>Should these operation always return a boolean instead of the result yielded by its operands?</Todo>

##### Other operators

| Operator   | Name            | Description                                                                                           |
| ---------- | --------------- | ----------------------------------------------------------------------------------------------------- |
| _a_ ?? _b_ | Null coalescing | Yields _a_ if it is not null. Otherwise yields _b_. Note that _b_ is only evaluated if _a_ is `null`. |

#### Assignment expressions

<Rules>

<Rule
  name="AssignExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "nonterminal", name: "AssignOp" },
    { type: "nonterminal", name: "Expr" }
  ]}
/>

<Rule
  name="AssignOp"
  definition={{
    type: "choice",
    children: ["=", "+=", "-=", "*=", "**=", "/=", "%="]
  }}
/>

</Rules>

<Todo>TODO</Todo>

#### Break expressions

<Rules>

<Rule name="BreakExpr" definition="break" />

</Rules>

Aborts execution of the current (most nested) _for_, _for each_ or _while_ loop.
Execution resumes directly after the loop statement.

Note that pending _defer_ statements will be executed before execution resumes after the loop.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    var i = 0;
    while (true) {
        if (i == 3) {
            break;
        }
        std.print(i);
        i += 1;
    }
    std.print("done");
}
```

#### Continue expressions

<Rules>

<Rule name="ContinueExpr" definition="continue" />

</Rules>

Jumps directly to the end of the current (most nested) _for_, _for each_ or _while_ loop's body.

Note that pending _defer_ statements will be executed before execution of the loop resumes.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    for var i = 0; i <= 6; i += 1 {
        if i % 2 == 0 {
          continue; // Skip even numbers
        }
        std.print(i);
    }
}
```

#### Return expressions

<Rules>

<Rule name="ReturnExpr" definition={["return", { type: "optional", child: { type: "nonterminal", name: "Expr" } }]} />

</Rules>

Returns from the current (most nested) function.
Program execution will continue in that function's caller.

An optional expression may be specified.
The value yielded by that expression will be come the function's return value.
If the expression is omitted, `null` is returned.

Note that pending _defer_ statements will be executed when returning from a function.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    std.print(next_even(1));
    std.print(next_even(2));
}

func next_even(n) {
    if (n % 2 == 0) {
        return n;
    }
    return n + 1;
}
```

#### Grouped expressions

<Rules>

<Rule name="GroupedExpr" definition={["(", { type: "nonterminal", name: "Expr" }, ")"]} />

</Rules>

Parentheses can be used to group expressions, for example to override the default precedence rules within expressions:

```tiro
import std;

export func main() {
    std.print(1 + 2 * 3);
    std.print((1 + 2) * 3);
}
```

#### If expressions

<Rules>

<Rule
  name="IfExpr"
  definition={[
    "if",
    { type: "nonterminal", name: "Expr" },
    { type: "nonterminal", name: "BlockExpr" },
    { type: "optional", child: ["else", { type: "nonterminal", name: "BlockExpr" }] }
  ]}
/>

</Rules>

#### Function expressions

<Rules>

<Rule name="FuncExpr" definition={{ type: "nonterminal", name: "FuncDecl" }} />

</Rules>

#### Block expressions

<Rules>

<Rule name="BlockExpr" definition={["{", { type: "repeat", child: { type: "nonterminal", name: "Stmt" } }, "}"]} />

</Rules>

### Literals

<Rules>

<Rule
  name="Literal"
  definition={{
    type: "choice",
    children: [
      "true",
      "false",
      "null",
      { type: "nonterminal", name: "Integer" },
      {
        type: "nonterminal",
        name: "Float"
      },
      {
        type: "nonterminal",
        name: "String"
      },
      {
        type: "nonterminal",
        name: "Symbol"
      },
      {
        type: "nonterminal",
        name: "TupleLiteral"
      },
      {
        type: "nonterminal",
        name: "RecordLiteral"
      },
      {
        type: "nonterminal",
        name: "ArrayLiteral"
      },
      {
        type: "nonterminal",
        name: "MapLiteral"
      },
      {
        type: "nonterminal",
        name: "SetLiteral"
      }
    ]
  }}
/>

<Rule
  name="TupleLiteral"
  definition={["(", { type: "optional", child: { type: "nonterminal", name: "TupleElements" } }, ")"]}
/>
<Rule
  name="TupleElements"
  definition={[
    { type: "repeat", min: 1, child: [{ type: "nonterminal", name: "Expr" }, ","] },
    {
      type: "optional",
      child: {
        type: "nonterminal",
        name: "Expr"
      }
    }
  ]}
/>

<Rule
  name="RecordLiteral"
  definition={[
    "(",
    {
      type: "choice",
      children: [{ type: "nonterminal", name: "RecordElements" }, ":"]
    },
    ")"
  ]}
/>

<Rule
  name="RecordElements"
  definition={[
    { type: "nonterminal", name: "RecordEntry" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "RecordEntry" }] },
    { type: "optional", child: "," }
  ]}
/>

<Rule
  name="RecordEntry"
  definition={[{ type: "nonterminal", name: "Identifier" }, ":", { type: "nonterminal", name: "Expr" }]}
/>

<Rule
  name="ArrayLiteral"
  definition={[
    "[",
    {
      type: "optional",
      child: {
        type: "nonterminal",
        name: "ArrayElements"
      }
    },
    "]"
  ]}
/>

<Rule
  name="ArrayElements"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Expr" }] },
    { type: "optional", child: "," }
  ]}
/>

<Rule
  name="MapLiteral"
  definition={[
    "map",
    "{",
    {
      type: "optional",
      child: {
        type: "nonterminal",
        name: "MapElements"
      }
    },
    "}"
  ]}
/>

<Rule
  name="MapElements"
  definition={[
    { type: "nonterminal", name: "MapEntry" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "MapEntry" }] },
    { type: "optional", child: "," }
  ]}
/>

<Rule
  name="MapEntry"
  definition={[{ type: "nonterminal", name: "Expr" }, ":", { type: "nonterminal", name: "Expr" }]}
/>

<Rule
  name="SetLiteral"
  definition={[
    "set",
    "{",
    {
      type: "optional",
      child: {
        type: "nonterminal",
        name: "SetElements"
      }
    },
    "}"
  ]}
/>

<Rule
  name="SetElements"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Expr" }] },
    { type: "optional", child: "," }
  ]}
/>

</Rules>

## Modules

<Todo>Documentation</Todo>
