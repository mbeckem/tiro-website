---
title: "Reference Documentation"
slug: "/reference"
---

# Tiro Reference Documentation

## Basics

Tiro accepts UTF-8 encoded source files as input.
Source files must conform to the rules outlined in this document to form a valid program.
At the very basic level, a source file will be recognized as a series of tokens.

<Info title="Note">

Grammar rules in this section work on _characters_.
No whitespace is not allowed unless it matches one of the required patterns.

</Info>

### Whitespace

Whitespace tokens consists of a sequence of characters having the Unicode _White_Space_ property. (TODO: White Space Pattern instead, add link)
Whitespace is not significant: its only use is to separate characters of adjacent tokens that would otherwise be parsed as a single token.

### Comments

Comments are used to annotate source code, but they have no meaning of their own.
They are simply treated as whitespace.

<Rules>

<Rule
  name="Comment"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "LineComment" },
      { type: "nonterminal", name: "BlockComment" }
    ]
  }}
/>

<Rule
  name="LineComment"
  definition={[
    "//",
    {
      type: "repeat",
      child: [
        {
          type: "not",
          child: "\\n"
        }
      ]
    }
  ]}
/>

<Rule
  name="BlockComment"
  definition={[
    "/*",
    {
      type: "repeat",
      child: {
        type: "choice",
        children: [
          { type: "nonterminal", name: "BlockComment" },
          { type: "repeat", child: { type: "not", child: "*/" } }
        ]
      }
    },
    "*/"
  ]}
/>

</Rules>

Line comments are introduced by `//` and continue until the end of the line.
Block comments are delimited by `/*` and `*/` and may be nested.

### Keywords

The following words have special meaning in the Tiro programming language:

<ItemTable
  columns={5}
  items={[
    "assert",
    "break",
    "const",
    "continue",
    "defer",
    "else",
    "export",
    "false",
    "for",
    "func",
    "if",
    "import",
    "in",
    "null",
    "return",
    "true",
    "var",
    "while"
  ]}
/>

#### Reserved keywords

The following keywords are reserved for future use:

<ItemTable
  columns={5}
  items={[
    "as",
    "catch",
    "class",
    "interface",
    "is",
    "package",
    "protocol",
    "scope",
    "struct",
    "switch",
    "throw",
    "try",
    "yield"
  ]}
/>

### Identifiers

Identifiers are used to name items.
They consist of one or more identifier characters as defined by the _XID_Start_ and _XID_Continue_ Unicode properties. (TODO: Link)
Keywords cannot be used as identifiers.

<Rules>

<Rule
  name="Identifier"
  definition={{
    type: "note",
    child: {
      type: "nonterminal",
      name: "KeywordOrIdentifier"
    },
    note: "Not including keywords"
  }}
/>

<Rule
  name="KeywordOrIdentifier"
  definition={[
    { type: "choice", children: [{ type: "nonterminal", name: "XID_Start", undefined: true }, "_"] },
    {
      type: "repeat",
      child: {
        type: "nonterminal",
        name: "XID_Continue",
        undefined: true
      }
    }
  ]}
/>

</Rules>

### Number literals

<Rules>

<Rule
  name="Integer"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "DecInteger" },
      { type: "nonterminal", name: "BinInteger" },
      { type: "nonterminal", name: "OctInteger" },
      { type: "nonterminal", name: "HexInteger" }
    ]
  }}
/>

<Rule
  name="DecInteger"
  definition={[
    { type: "nonterminal", name: "DecDigit" },
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "DecDigit" }, "_"] }
    }
  ]}
/>

<Rule
  name="BinInteger"
  definition={[
    "0b",
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "BinDigit" }, "_"] }
    },
    { type: "nonterminal", name: "BinDigit" },
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "BinDigit" }, "_"] }
    }
  ]}
/>

<Rule
  name="OctInteger"
  definition={[
    "0o",
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "OctDigit" }, "_"] }
    },
    { type: "nonterminal", name: "OctDigit" },
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "OctDigit" }, "_"] }
    }
  ]}
/>

<Rule
  name="HexInteger"
  definition={[
    "0x",
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "HexDigit" }, "_"] }
    },
    { type: "nonterminal", name: "HexDigit" },
    {
      type: "repeat",
      child: { type: "choice", children: [{ type: "nonterminal", name: "HexDigit" }, "_"] }
    }
  ]}
/>

<Rule
  name="DecDigit"
  definition={{
    type: "range",
    value: ["0", "9"]
  }}
/>

<Rule
  name="BinDigit"
  definition={{
    type: "choice",
    children: ["0", "1"]
  }}
/>

<Rule
  name="OctDigit"
  definition={{
    type: "range",
    value: ["0", "7"]
  }}
/>

<Rule
  name="HexDigit"
  definition={{
    type: "choice",
    children: [
      { type: "range", value: ["0", "9"] },
      { type: "range", value: ["a", "f"] },
      { type: "range", value: ["A", "F"] }
    ]
  }}
/>

</Rules>

<Todo>
  
Document floating point numbers.

</Todo>

### String literals

Strings are sequences of characters enclosed by matching quote characters (`"` or `'`).
Within a string, variables can be interpolated when prefixed with a `$` sign and full expressions can be interpolated when enclosed within a
block started with `${` and closed with a `}` sign.

<Rules>

<Rule
  name="String"
  definition={[
    {
      type: "nonterminal",
      name: "StringDelimiter"
    },
    {
      type: "repeat",
      child: {
        type: "choice",
        children: [
          { type: "nonterminal", name: "PlainStringContent" },
          { type: "nonterminal", name: "EscapeSequence" },
          { type: "nonterminal", name: "InterpolatedValue" }
        ]
      }
    },
    {
      type: "note",
      child: {
        type: "nonterminal",
        name: "StringDelimiter"
      },
      note: "matches starting delimiter"
    }
  ]}
/>

<Rule name="StringDelimiter" definition={{ type: "choice", children: ['"', "'"] }} />

<Rule
  name="PlainStringContent"
  definition={{
    type: "repeat",
    child: {
      type: "not",
      child: {
        type: "choice",
        children: [
          "\\",
          "$",
          {
            type: "note",
            child: {
              type: "nonterminal",
              name: "StringDelimiter"
            },
            note: "matches starting delimiter"
          }
        ]
      }
    }
  }}
/>

<Rule
  name="InterpolatedValue"
  definition={{
    type: "choice",
    children: [
      ["$", { type: "nonterminal", name: "Identifier" }],
      ["${", { type: "nonterminal", name: "Expr" }, "}"]
    ]
  }}
/>

</Rules>

<Todo>

Open design questions:

- Should strings be multi line by default (current state)? Or should a `\` at the end of a line be necessary to continue to the following line?
- Should all strings support interpolation by default? Or provide a variant (e.g. delimited by `'`) that does _not_ support interpolation?
- Should all strings be guaranteed (required) to be valid UTF-8?

</Todo>

#### Escape sequences

<Rules>

<Rule
  name="EscapeSequence"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "EscapedCharacter" },
      { type: "nonterminal", name: "AsciiEscape" },
      { type: "nonterminal", name: "UnicodeEscape" }
    ]
  }}
/>

<Rule
  name="EscapedCharacter"
  definition={{ type: "choice", children: ["\\\\", "\\n", "\\r", "\\t", '\\"', "\\'", "\\$"] }}
/>

<Rule
  name="AsciiEscape"
  definition={["\\x", { type: "nonterminal", name: "HexDigit" }, { type: "nonterminal", name: "HexDigit" }]}
/>

<Rule
  name="UnicodeEscape"
  definition={[
    "\\u{",
    {
      type: "repeat",
      min: 1,
      child: {
        type: "nonterminal",
        name: "HexDigit"
      }
    },
    "}"
  ]}
/>

</Rules>

Escape sequences produce the following string content:

| Escape Sequence    | Production                  |
| ------------------ | --------------------------- | ------------------------------------------------------------------------------------------ |
| `\\`               | Literal `\`                 |                                                                                            |
| `\n`               | Newline                     |                                                                                            |
| `\r`               | Carriage return             |                                                                                            |
| `\t`               | Tabulator                   |                                                                                            |
| `\"`               | Literal `"`                 |                                                                                            |
| `\'`               | Literal `'`                 |                                                                                            |
| `\$`               | Literal `$`                 |                                                                                            |
| `\x` digits..      | A single byte               | The numeric value of the two hex digits is produced as a byte (TODO: Must be valid utf-8?) |
| `\u{` digits.. `}` | A single unicode code point | The sequence of hex digits is interpreted as the value of a unicode code point.            |

### Symbol literals

<Rules>

<Rule name="Symbol" definition={["#", { type: "nonterminal", name: "Identifier" }]} />

</Rules>

<Todo>

Documentation

</Todo>

## Grammar

<Info title="Note">

Grammar rules in this section work on _tokens_.
Any amount of white space may appear between matching tokens.

</Info>

### Items

<Rules>

<Rule
  name="File"
  definition={{
    type: "repeat",
    child: {
      type: "nonterminal",
      name: "Item"
    }
  }}
/>

<Rule
  name="Item"
  definition={[
    {
      type: "optional",
      child: "export"
    },
    {
      type: "choice",
      children: [
        [{ type: "nonterminal", name: "ImportDecl" }, ";"],
        [{ type: "nonterminal", name: "VarDecl" }, ";"],
        [{ type: "nonterminal", name: "FuncDecl" }]
      ]
    }
  ]}
/>

</Rules>

A Tiro source file is a sequence of _Items_.
An item containing the `export` modifier will be exported from the current module.
Exported items are visible to other modules and may be imported.

#### Imports

<Rules>

<Rule
  name="ImportDecl"
  definition={[
    "import",
    {
      type: "nonterminal",
      name: "ImportPath"
    },
    {
      type: "optional",
      child: ["as", { type: "nonterminal", name: "Identifier" }]
    }
  ]}
/>

<Rule
  name="ImportPath"
  definition={[
    { type: "nonterminal", name: "Identifier" },
    {
      type: "repeat",
      child: [".", { type: "nonterminal", name: "Identifier" }]
    }
  ]}
/>

</Rules>

An `import` item imports the module referenced by the _ImportPath_ and introduces it into the current scope.
The last _Identifier_ in the _ImportPath_ serves as the name of the imported reference by default.
A custom name may be provided by using the `as` keyword.

<Todo>
  
The import path must currently point to a module.
It should also allow for entities within a module.
For example, `import std.print as myprint` should be valid.

Grouping imports should be possible, for example `import std { print, PI as MY_PI}`.

</Todo>

#### Variables

<Rules>

<Rule
  name="VarDecl"
  definition={[
    { type: "choice", children: ["const", "var"] },
    { type: "nonterminal", name: "Binding" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Binding" }] }
  ]}
/>

<Rule
  name="Binding"
  definition={[
    { type: "nonterminal", name: "BindingPattern" },
    { type: "optional", child: ["=", { type: "nonterminal", name: "Expr" }] }
  ]}
/>

<Rule
  name="BindingPattern"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "Identifier" },
      { type: "nonterminal", name: "TupleBindingPattern" }
    ]
  }}
/>

<Rule
  name="TupleBindingPattern"
  definition={[
    "(",
    { type: "nonterminal", name: "Identifier" },
    {
      type: "repeat",
      child: [",", { type: "nonterminal", name: "Identifier" }]
    },
    ")"
  ]}
/>

</Rules>

Variable declarations introduce one or more variables into the current scope.
Each variable is defined by a _Binding_, which may provide an initializer expression for the _Identifier_ or _Identifiers_ mentioned in the _BindingPattern_.

Bindings introduce a single new variable when the _BindingPattern_ consists of a single identifier.
The optional initializer expression may produce any value in this case.
A _TupleBindingPattern_ introduces multiple variables at once.
The optional initializer for a tuple pattern must produce a tuple value with a compatible size (at least the number of declared variable names).

Using the `var` keyword creates a mutable variable, while a variable declared using the `const` keyword cannot be reassigned after its initialization.
Constants must have an initializer.

| Declaration kind     | Example                | Meaning                                                              |
| -------------------- | ---------------------- | -------------------------------------------------------------------- |
| Simple declaration   | `var x;`               | Declares the initialized variable _x_ in the current scope           |
| Multiple variables   | `var x, y;`            | Declares _x_ and _y_ in the current scope                            |
| With initializer     | `var x = 3.14;`        | Declares _x_ and with the initial value `3.14`                       |
| Constant declaration | `const x = 3.14; `     | Like the above, but _x_ cannot be reassigned anymore                 |
| Tuple unpacking      | `var (x, y) = (1, 2);` | Unpacks the right hand side tuple into the new variables _x_ and _y_ |

#### Functions

<Rules>

<Rule
  name="FuncDecl"
  definition={[
    "func",
    { type: "optional", child: { type: "nonterminal", name: "Identifier" } },
    "(",
    { type: "optional", child: { type: "nonterminal", name: "ParamList" } },
    ")",
    { type: "nonterminal", name: "FuncBody" }
  ]}
/>

<Rule
  name="ParamList"
  definition={[
    { type: "nonterminal", name: "Identifier" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Identifier" }] }
  ]}
/>

<Rule
  name="FuncBody"
  definition={{
    type: "choice",
    children: [["=", { type: "nonterminal", name: "Expr" }], { type: "nonterminal", name: "BlockExpr" }]
  }}
/>

</Rules>

A function declaration introduce a function into the current scope.
Functions may have a name, a set of parameters and a body.

The body of a function may be specified as either a _BlockExpr_ or as a single expression introduced by a `=` sign.
The shorthand syntax is useful for very simple functions.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    std.print(block_body(1));
    std.print(shorthand_body(2));
}

func block_body(p) {
    const result = p * 2;
    return result;
}

func shorthand_body(p) = p * 2;
```

### Statements

<Rules>

<Rule
  name="Stmt"
  definition={{
    type: "choice",
    children: [
      [{ type: "nonterminal", name: "VarDecl" }, ";"],
      [{ type: "nonterminal", name: "AssertStmt" }, ";"],
      [{ type: "nonterminal", name: "DeferStmt" }, ";"],
      [{ type: "nonterminal", name: "WhileStmt" }],
      [{ type: "nonterminal", name: "ForEachStmt" }],
      [{ type: "nonterminal", name: "ForStmt" }],
      [{ type: "nonterminal", name: "IfExpr" }],
      [{ type: "nonterminal", name: "BlockExpr" }],
      [{ type: "nonterminal", name: "Expr" }, ";"],
      ";"
    ]
  }}
/>

</Rules>

Statements are constructs used in block expressions such as function bodies.
Most statements must be terminated with a semicolon.
The semicolon is optional for block-like statements, where the end of the statement is obvious from the position of the closing `}`.

#### Assertions

<Rules>

<Rule
  name="AssertStmt"
  definition={[
    "assert",
    "(",
    { type: "nonterminal", name: "Expr" },
    { type: "optional", child: [",", { type: "nonterminal", name: "StringExpr" }] },
    ")"
  ]}
/>

</Rules>

An assertion verifies that the expression produces a truthful value.
A failed assertion results in a _panic_.

An optional message argument may be specified; it will be included in the panic's diagnostic error message.

#### Defer statements

<Rules>

<Rule name="DeferStmt" definition={["defer", { type: "nonterminal", name: "Expr" }]} />

</Rules>

The defer statement registers an expression to be evaluated when the program leaves the current scope.
It's main use is to ensure that resources are cleaned up properly.

Defer statements that have been visited by the program will run even if the scope is being left abrubtly, such as by an early `return`, `break`, `continue` or a panic.

<span className="caption">Example:</span>

```tiro
import std;

export func main() {
    std.print("aquire resource");
    defer std.print("release resource");
    std.print("use resource");
}
```

#### While loops

<Rules>

<Rule
  name="WhileStmt"
  definition={["while", { type: "nonterminal", name: "Expr" }, { type: "nonterminal", name: "BlockExpr" }]}
/>

</Rules>

#### For-each loops

<Rules>

<Rule
  name="ForEachStmt"
  definition={[
    "for",
    { type: "nonterminal", name: "BindingPattern" },
    "in",
    { type: "nonterminal", name: "Expr" },
    { type: "nonterminal", name: "BlockExpr" }
  ]}
/>

</Rules>

#### Classic for loops

<Rules>

<Rule
  name="ForStmt"
  definition={[
    "for",
    { type: "optional", child: { type: "nonterminal", name: "VarDecl" } },
    ";",
    { type: "optional", child: { type: "nonterminal", name: "Expr" } },
    ";",
    { type: "optional", child: { type: "nonterminal", name: "Expr" } },
    { type: "nonterminal", name: "BlockExpr" }
  ]}
/>

</Rules>

### Expressions

<Rules>

<Rule
  name="Expr"
  definition={{
    type: "choice",
    children: [
      { type: "nonterminal", name: "VarExpr" },
      { type: "nonterminal", name: "FieldExpr" },
      { type: "nonterminal", name: "TupleFieldExpr" },
      { type: "nonterminal", name: "ElementExpr" },
      { type: "nonterminal", name: "CallExpr" },
      { type: "nonterminal", name: "UnaryExpr" },
      { type: "nonterminal", name: "BinaryExpr" },
      { type: "nonterminal", name: "AssignExpr" },
      { type: "nonterminal", name: "ContinueExpr" },
      { type: "nonterminal", name: "BreakExpr" },
      { type: "nonterminal", name: "ReturnExpr" },
      { type: "nonterminal", name: "GroupedExpr" },
      { type: "nonterminal", name: "IfExpr" },
      { type: "nonterminal", name: "FuncExpr" },
      { type: "nonterminal", name: "BlockExpr" }
    ]
  }}
/>

<Rule
  name="VarExpr"
  definition={{
    type: "nonterminal",
    name: "Identifier"
  }}
/>

<Rule
  name="FieldExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "choice", children: [".", "?."] },
    { type: "nonterminal", name: "Identifier" }
  ]}
/>

<Rule
  name="TupleFieldExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "choice", children: [".", "?."] },
    { type: "nonterminal", name: "NonNegativeInt" }
  ]}
/>

<Rule
  name="ElementExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "choice", children: ["[", "?["] },
    { type: "nonterminal", name: "Expr" },
    "]"
  ]}
/>

<Rule
  name="CallExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "choice", children: ["(", "?("] },
    { type: "optional", child: { type: "nonterminal", name: "CallArguments" } },
    ")"
  ]}
/>

<Rule
  name="CallArguments"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Expr" }] }
  ]}
/>

<Rule
  name="UnaryExpr"
  definition={[
    { type: "nonterminal", name: "UnaryOp" },
    { type: "nonterminal", name: "Expr" }
  ]}
/>

<Rule name="UnaryOp" definition={{ type: "choice", children: ["+", "-", "!", "~"] }} />

<Rule
  name="BinaryExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "nonterminal", name: "BinaryOp" },
    { type: "nonterminal", name: "Expr" }
  ]}
/>

<Rule
  name="BinaryOp"
  definition={{
    type: "choice",
    children: [
      "+",
      "-",
      "*",
      "**",
      "/",
      "%",
      "<<",
      ">>",
      "&",
      "|",
      "^",
      "<",
      ">",
      "<=",
      ">=",
      "==",
      "!=",
      "??",
      "&&",
      "||"
    ]
  }}
/>

<Rule
  name="AssignExpr"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "nonterminal", name: "AssignOp" },
    { type: "nonterminal", name: "Expr" }
  ]}
/>

<Rule
  name="AssignOp"
  definition={{
    type: "choice",
    children: ["=", "+=", "-=", "*=", "**=", "/=", "%="]
  }}
/>

<Rule name="ContinueExpr" definition="continue" />

<Rule name="BreakExpr" definition="break" />

<Rule name="ReturnExpr" definition={["return", { type: "optional", child: { type: "nonterminal", name: "Expr" } }]} />

<Rule name="GroupedExpr" definition={["(", { type: "nonterminal", name: "Expr" }, ")"]} />

<Rule
  name="IfExpr"
  definition={[
    "if",
    { type: "nonterminal", name: "Expr" },
    { type: "nonterminal", name: "BlockExpr" },
    { type: "optional", child: ["else", { type: "nonterminal", name: "BlockExpr" }] }
  ]}
/>

<Rule name="FuncExpr" definition={{ type: "nonterminal", name: "FuncDecl" }} />

<Rule name="BlockExpr" definition={["{", { type: "repeat", child: { type: "nonterminal", name: "Stmt" } }, "}"]} />

</Rules>

### Literals

<Rules>

<Rule
  name="Literal"
  definition={{
    type: "choice",
    children: [
      "true",
      "false",
      "null",
      { type: "nonterminal", name: "Integer" },
      {
        type: "nonterminal",
        name: "Float"
      },
      {
        type: "nonterminal",
        name: "String"
      },
      {
        type: "nonterminal",
        name: "Symbol"
      },
      {
        type: "nonterminal",
        name: "TupleLiteral"
      },
      {
        type: "nonterminal",
        name: "RecordLiteral"
      },
      {
        type: "nonterminal",
        name: "ArrayLiteral"
      },
      {
        type: "nonterminal",
        name: "MapLiteral"
      },
      {
        type: "nonterminal",
        name: "SetLiteral"
      }
    ]
  }}
/>

<Rule
  name="TupleLiteral"
  definition={["(", { type: "optional", child: { type: "nonterminal", name: "TupleElements" } }, ")"]}
/>
<Rule
  name="TupleElements"
  definition={[
    { type: "repeat", min: 1, child: [{ type: "nonterminal", name: "Expr" }, ","] },
    {
      type: "optional",
      child: {
        type: "nonterminal",
        name: "Expr"
      }
    }
  ]}
/>

<Rule
  name="RecordLiteral"
  definition={[
    "(",
    {
      type: "choice",
      children: [{ type: "nonterminal", name: "RecordElements" }, ":"]
    },
    ")"
  ]}
/>

<Rule
  name="RecordElements"
  definition={[
    { type: "nonterminal", name: "RecordEntry" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "RecordEntry" }] },
    { type: "optional", child: "," }
  ]}
/>

<Rule
  name="RecordEntry"
  definition={[{ type: "nonterminal", name: "Identifier" }, ":", { type: "nonterminal", name: "Expr" }]}
/>

<Rule
  name="ArrayLiteral"
  definition={[
    "[",
    {
      type: "optional",
      child: {
        type: "nonterminal",
        name: "ArrayElements"
      }
    },
    "]"
  ]}
/>

<Rule
  name="ArrayElements"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Expr" }] },
    { type: "optional", child: "," }
  ]}
/>

<Rule
  name="MapLiteral"
  definition={[
    "map",
    "{",
    {
      type: "optional",
      child: {
        type: "nonterminal",
        name: "MapElements"
      }
    },
    "}"
  ]}
/>

<Rule
  name="MapElements"
  definition={[
    { type: "nonterminal", name: "MapEntry" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "MapEntry" }] },
    { type: "optional", child: "," }
  ]}
/>

<Rule
  name="MapEntry"
  definition={[{ type: "nonterminal", name: "Expr" }, ":", { type: "nonterminal", name: "Expr" }]}
/>

<Rule
  name="SetLiteral"
  definition={[
    "set",
    "{",
    {
      type: "optional",
      child: {
        type: "nonterminal",
        name: "SetElements"
      }
    },
    "}"
  ]}
/>

<Rule
  name="SetElements"
  definition={[
    { type: "nonterminal", name: "Expr" },
    { type: "repeat", child: [",", { type: "nonterminal", name: "Expr" }] },
    { type: "optional", child: "," }
  ]}
/>

</Rules>

## Modules

<Todo>Documentation</Todo>
